{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/type-check.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/evented.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/node_modules/.pnpm/deepmerge-ts@7.1.5/node_modules/deepmerge-ts/dist/index.mjs", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/auto-bind.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/bind.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/general.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/node_modules/.pnpm/@floating-ui+core@1.7.4/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/node_modules/.pnpm/@floating-ui+utils@0.2.10/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/node_modules/.pnpm/@floating-ui+dom@1.7.5/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/floating-ui.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/dom.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-button.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-header.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-title.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-cancel-icon.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-content.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-text.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-footer.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/step.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-element.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/components/shepherd-modal.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/overlay-path.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/tour.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/shepherd.ts", "../../../../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/src/utils/cleanup.ts"],
  "sourcesContent": ["/**\n * Checks if `value` is classified as an `Element`.\n * @param value The param to check if it is an Element\n */\nexport function isElement<T>(value: T | Element): value is Element {\n  return value instanceof Element;\n}\n\n/**\n * Checks if `value` is classified as an `HTMLElement`.\n * @param value The param to check if it is an HTMLElement\n */\nexport function isHTMLElement<T>(value: T | HTMLElement): value is HTMLElement {\n  return value instanceof HTMLElement;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n * @param value The param to check if it is a function\n */\nexport function isFunction<T>(value: T | Function): value is Function {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param value The param to check if it is a string\n */\nexport function isString<T>(value: T | string): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param value The param to check if it is undefined\n */\nexport function isUndefined<T>(value: T | undefined): value is undefined {\n  return value === undefined;\n}\n", "import { isUndefined } from './utils/type-check.ts';\n\nexport type Bindings = {\n  [key: string]: Array<{ handler: () => void; ctx?: unknown; once?: boolean }>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyHandler = (...args: any[]) => void;\n\nexport class Evented {\n  declare bindings: Bindings;\n\n  /**\n   * Adds an event listener for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @param ctx\n   * @param {boolean} once\n   * @returns\n   */\n  on(event: string, handler: AnyHandler, ctx?: unknown, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event]?.push({ handler, ctx, once });\n\n    return this;\n  }\n\n  /**\n   * Adds an event listener that only fires once for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @param ctx\n   * @returns\n   */\n  once(event: string, handler: AnyHandler, ctx?: unknown) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  /**\n   * Removes an event listener for the given event string.\n   *\n   * @param {string} event\n   * @param {Function} handler\n   * @returns\n   */\n  off(event: string, handler?: AnyHandler) {\n    if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      this.bindings[event]?.forEach((binding, index) => {\n        if (binding.handler === handler) {\n          this.bindings[event]?.splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Triggers an event listener for the given event string.\n   *\n   * @param {string} event\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  trigger(event: string, ...args: any[]) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      this.bindings[event]?.forEach((binding, index) => {\n        const { ctx, handler, once } = binding;\n\n        const context = ctx || this;\n\n        handler.apply(context, args as []);\n\n        if (once) {\n          this.bindings[event]?.splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n", "/**\n * Special values that tell deepmerge to perform a certain action.\n */\nconst actions = {\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n    skip: Symbol(\"deepmerge-ts: skip\"),\n};\n/**\n * Special values that tell deepmergeInto to perform a certain action.\n */\nconst actionsInto = {\n    defaultMerge: actions.defaultMerge,\n};\n\n/**\n * The default function to update meta data.\n *\n * It doesn't update the meta data.\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n    return metaMeta;\n}\n/**\n * The default function to filter values.\n *\n * It filters out undefined values.\n */\nfunction defaultFilterValues(values, meta) {\n    return values.filter((value) => value !== undefined);\n}\n\n/**\n * The different types of objects deepmerge-ts support.\n */\nvar ObjectType;\n(function (ObjectType) {\n    ObjectType[ObjectType[\"NOT\"] = 0] = \"NOT\";\n    ObjectType[ObjectType[\"RECORD\"] = 1] = \"RECORD\";\n    ObjectType[ObjectType[\"ARRAY\"] = 2] = \"ARRAY\";\n    ObjectType[ObjectType[\"SET\"] = 3] = \"SET\";\n    ObjectType[ObjectType[\"MAP\"] = 4] = \"MAP\";\n    ObjectType[ObjectType[\"OTHER\"] = 5] = \"OTHER\";\n})(ObjectType || (ObjectType = {}));\n/**\n * Get the type of the given object.\n *\n * @param object - The object to get the type of.\n * @returns The type of the given object.\n */\nfunction getObjectType(object) {\n    if (typeof object !== \"object\" || object === null) {\n        return 0 /* ObjectType.NOT */;\n    }\n    if (Array.isArray(object)) {\n        return 2 /* ObjectType.ARRAY */;\n    }\n    if (isRecord(object)) {\n        return 1 /* ObjectType.RECORD */;\n    }\n    if (object instanceof Set) {\n        return 3 /* ObjectType.SET */;\n    }\n    if (object instanceof Map) {\n        return 4 /* ObjectType.MAP */;\n    }\n    return 5 /* ObjectType.OTHER */;\n}\n/**\n * Get the keys of the given objects including symbol keys.\n *\n * Note: Only keys to enumerable properties are returned.\n *\n * @param objects - An array of objects to get the keys of.\n * @returns A set containing all the keys of all the given objects.\n */\nfunction getKeys(objects) {\n    const keys = new Set();\n    for (const object of objects) {\n        for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n            keys.add(key);\n        }\n    }\n    return keys;\n}\n/**\n * Does the given object have the given property.\n *\n * @param object - The object to test.\n * @param property - The property to test.\n * @returns Whether the object has the property.\n */\nfunction objectHasProperty(object, property) {\n    return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\n * Get an iterable object that iterates over the given iterables.\n */\nfunction getIterableOfIterables(iterables) {\n    let mut_iterablesIndex = 0;\n    let mut_iterator = iterables[0]?.[Symbol.iterator]();\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    do {\n                        if (mut_iterator === undefined) {\n                            return { done: true, value: undefined };\n                        }\n                        const result = mut_iterator.next();\n                        if (result.done === true) {\n                            mut_iterablesIndex += 1;\n                            mut_iterator = iterables[mut_iterablesIndex]?.[Symbol.iterator]();\n                            continue;\n                        }\n                        return {\n                            done: false,\n                            value: result.value,\n                        };\n                    } while (true);\n                },\n            };\n        },\n    };\n}\n// eslint-disable-next-line unicorn/prefer-set-has -- Array is more performant for a low number of elements.\nconst validRecordToStringValues = [\"[object Object]\", \"[object Module]\"];\n/**\n * Does the given object appear to be a record.\n */\nfunction isRecord(value) {\n    // All records are objects.\n    if (!validRecordToStringValues.includes(Object.prototype.toString.call(value))) {\n        return false;\n    }\n    const { constructor } = value;\n    // If has modified constructor.\n    // eslint-disable-next-line ts/no-unnecessary-condition\n    if (constructor === undefined) {\n        return true;\n    }\n    const prototype = constructor.prototype;\n    // If has modified prototype.\n    if (prototype === null ||\n        typeof prototype !== \"object\" ||\n        !validRecordToStringValues.includes(Object.prototype.toString.call(prototype))) {\n        return false;\n    }\n    // If constructor does not have an Object-specific method.\n    // eslint-disable-next-line sonar/prefer-single-boolean-return, no-prototype-builtins\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n        return false;\n    }\n    // Most likely a record.\n    return true;\n}\n\n/**\n * The default strategy to merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords$1(values, utils, meta) {\n    const result = {};\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n        if (propertyResult === actions.skip) {\n            continue;\n        }\n        if (key === \"__proto__\") {\n            Object.defineProperty(result, key, {\n                value: propertyResult,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            result[key] = propertyResult;\n        }\n    }\n    return result;\n}\n/**\n * The default strategy to merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays$1(values) {\n    return values.flat();\n}\n/**\n * The default strategy to merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets$1(values) {\n    return new Set(getIterableOfIterables(values));\n}\n/**\n * The default strategy to merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps$1(values) {\n    return new Map(getIterableOfIterables(values));\n}\n/**\n * Get the last value in the given array.\n */\nfunction mergeOthers$1(values) {\n    return values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeFunctions = {\n    mergeRecords: mergeRecords$1,\n    mergeArrays: mergeArrays$1,\n    mergeSets: mergeSets$1,\n    mergeMaps: mergeMaps$1,\n    mergeOthers: mergeOthers$1,\n};\n\n/**\n * Deeply merge objects.\n *\n * @param objects - The objects to merge.\n */\nfunction deepmerge(...objects) {\n    return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n    const utils = getUtils(options, customizedDeepmerge);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmerge(...objects) {\n        return mergeUnknowns(objects, utils, rootMetaData);\n    }\n    return customizedDeepmerge;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getUtils(options, customizedDeepmerge) {\n    return {\n        defaultMergeFunctions: mergeFunctions,\n        mergeFunctions: {\n            ...mergeFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmerge: customizedDeepmerge,\n        useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions,\n    };\n}\n/**\n * Merge unknown things.\n *\n * @param values - The values.\n */\nfunction mergeUnknowns(values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return undefined;\n    }\n    if (filteredValues.length === 1) {\n        return mergeOthers(filteredValues, utils, meta);\n    }\n    const type = getObjectType(filteredValues[0]);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let mut_index = 1; mut_index < filteredValues.length; mut_index++) {\n            if (getObjectType(filteredValues[mut_index]) === type) {\n                continue;\n            }\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return mergeRecords(filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return mergeArrays(filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return mergeSets(filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return mergeMaps(filteredValues, utils, meta);\n        }\n        default: {\n            return mergeOthers(filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records.\n *\n * @param values - The records.\n */\nfunction mergeRecords(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords)) {\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n    }\n    return result;\n}\n/**\n * Merge arrays.\n *\n * @param values - The arrays.\n */\nfunction mergeArrays(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays)) {\n        return utils.defaultMergeFunctions.mergeArrays(values);\n    }\n    return result;\n}\n/**\n * Merge sets.\n *\n * @param values - The sets.\n */\nfunction mergeSets(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\n        return utils.defaultMergeFunctions.mergeSets(values);\n    }\n    return result;\n}\n/**\n * Merge maps.\n *\n * @param values - The maps.\n */\nfunction mergeMaps(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\n        return utils.defaultMergeFunctions.mergeMaps(values);\n    }\n    return result;\n}\n/**\n * Merge other things.\n *\n * @param values - The other things.\n */\nfunction mergeOthers(values, utils, meta) {\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n    if (result === actions.defaultMerge ||\n        (utils.useImplicitDefaultMerging &&\n            result === undefined &&\n            utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers)) {\n        return utils.defaultMergeFunctions.mergeOthers(values);\n    }\n    return result;\n}\n\n/**\n * The default strategy to merge records into a target record.\n *\n * @param mut_target - The result will be mutated into this record\n * @param values - The records (including the target's value if there is one).\n */\nfunction mergeRecordsInto$1(mut_target, values, utils, meta) {\n    for (const key of getKeys(values)) {\n        const propValues = [];\n        for (const value of values) {\n            if (objectHasProperty(value, key)) {\n                propValues.push(value[key]);\n            }\n        }\n        if (propValues.length === 0) {\n            continue;\n        }\n        const updatedMeta = utils.metaDataUpdater(meta, {\n            key,\n            parents: values,\n        });\n        const propertyTarget = { value: propValues[0] };\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n        if (key === \"__proto__\") {\n            Object.defineProperty(mut_target.value, key, {\n                value: propertyTarget.value,\n                configurable: true,\n                enumerable: true,\n                writable: true,\n            });\n        }\n        else {\n            mut_target.value[key] = propertyTarget.value;\n        }\n    }\n}\n/**\n * The default strategy to merge arrays into a target array.\n *\n * @param mut_target - The result will be mutated into this array\n * @param values - The arrays (including the target's value if there is one).\n */\nfunction mergeArraysInto$1(mut_target, values) {\n    mut_target.value.push(...values.slice(1).flat());\n}\n/**\n * The default strategy to merge sets into a target set.\n *\n * @param mut_target - The result will be mutated into this set\n * @param values - The sets (including the target's value if there is one).\n */\nfunction mergeSetsInto$1(mut_target, values) {\n    for (const value of getIterableOfIterables(values.slice(1))) {\n        mut_target.value.add(value);\n    }\n}\n/**\n * The default strategy to merge maps into a target map.\n *\n * @param mut_target - The result will be mutated into this map\n * @param values - The maps (including the target's value if there is one).\n */\nfunction mergeMapsInto$1(mut_target, values) {\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n        mut_target.value.set(key, value);\n    }\n}\n/**\n * Set the target to the last value.\n */\nfunction mergeOthersInto$1(mut_target, values) {\n    mut_target.value = values.at(-1);\n}\n/**\n * The merge functions.\n */\nconst mergeIntoFunctions = {\n    mergeRecords: mergeRecordsInto$1,\n    mergeArrays: mergeArraysInto$1,\n    mergeSets: mergeSetsInto$1,\n    mergeMaps: mergeMapsInto$1,\n    mergeOthers: mergeOthersInto$1,\n};\n\nfunction deepmergeInto(target, ...objects) {\n    return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\n    /**\n     * The customized deepmerge function.\n     */\n    function customizedDeepmergeInto(target, ...objects) {\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\n    }\n    return customizedDeepmergeInto;\n}\n/**\n * The the utils that are available to the merge functions.\n *\n * @param options - The options the user specified\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n    return {\n        defaultMergeFunctions: mergeIntoFunctions,\n        mergeFunctions: {\n            ...mergeIntoFunctions,\n            ...Object.fromEntries(Object.entries(options)\n                .filter(([key, option]) => Object.hasOwn(mergeIntoFunctions, key))\n                .map(([key, option]) => (option === false ? [key, mergeIntoFunctions.mergeOthers] : [key, option]))),\n        },\n        metaDataUpdater: (options.metaDataUpdater ?? defaultMetaDataUpdater),\n        deepmergeInto: customizedDeepmergeInto,\n        filterValues: options.filterValues === false ? undefined : (options.filterValues ?? defaultFilterValues),\n        actions: actionsInto,\n    };\n}\n/**\n * Merge unknown things into a target.\n *\n * @param mut_target - The target to merge into.\n * @param values - The values.\n */\nfunction mergeUnknownsInto(mut_target, values, utils, meta) {\n    const filteredValues = utils.filterValues?.(values, meta) ?? values;\n    if (filteredValues.length === 0) {\n        return;\n    }\n    if (filteredValues.length === 1) {\n        return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n    }\n    const type = getObjectType(mut_target.value);\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n        for (let mut_index = 1; mut_index < filteredValues.length; mut_index++) {\n            if (getObjectType(filteredValues[mut_index]) === type) {\n                continue;\n            }\n            return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n        }\n    }\n    switch (type) {\n        case 1 /* ObjectType.RECORD */: {\n            return void mergeRecordsInto(mut_target, filteredValues, utils, meta);\n        }\n        case 2 /* ObjectType.ARRAY */: {\n            return void mergeArraysInto(mut_target, filteredValues, utils, meta);\n        }\n        case 3 /* ObjectType.SET */: {\n            return void mergeSetsInto(mut_target, filteredValues, utils, meta);\n        }\n        case 4 /* ObjectType.MAP */: {\n            return void mergeMapsInto(mut_target, filteredValues, utils, meta);\n        }\n        default: {\n            return void mergeOthersInto(mut_target, filteredValues, utils, meta);\n        }\n    }\n}\n/**\n * Merge records into a target record.\n *\n * @param mut_target - The target to merge into.\n * @param values - The records.\n */\nfunction mergeRecordsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeRecords(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeRecords(mut_target, values, utils, meta);\n    }\n}\n/**\n * Merge arrays into a target array.\n *\n * @param mut_target - The target to merge into.\n * @param values - The arrays.\n */\nfunction mergeArraysInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeArrays(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeArrays(mut_target, values);\n    }\n}\n/**\n * Merge sets into a target set.\n *\n * @param mut_target - The target to merge into.\n * @param values - The sets.\n */\nfunction mergeSetsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeSets(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeSets(mut_target, values);\n    }\n}\n/**\n * Merge maps into a target map.\n *\n * @param mut_target - The target to merge into.\n * @param values - The maps.\n */\nfunction mergeMapsInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeMaps(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeMaps(mut_target, values);\n    }\n}\n/**\n * Merge other things into a target.\n *\n * @param mut_target - The target to merge into.\n * @param values - The other things.\n */\nfunction mergeOthersInto(mut_target, values, utils, meta) {\n    const action = utils.mergeFunctions.mergeOthers(mut_target, values, utils, meta);\n    if (action === actionsInto.defaultMerge || mut_target.value === actionsInto.defaultMerge) {\n        utils.defaultMergeFunctions.mergeOthers(mut_target, values);\n    }\n}\n\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom, getKeys, getObjectType, objectHasProperty };\n", "/**\n * Binds all the methods on a JS Class to the `this` context of the class.\n * Adapted from https://github.com/sindresorhus/auto-bind\n * @param self The `this` context of the class\n * @return The `this` context of the class\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport default function autoBind(self: any) {\n  const keys = Object.getOwnPropertyNames(self.constructor.prototype);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i] as keyof typeof self;\n    const val = self[key];\n    if (key !== 'constructor' && typeof val === 'function') {\n      self[key] = val.bind(self);\n    }\n  }\n\n  return self;\n}\n", "import type { Step } from '../step.ts';\nimport { isUndefined } from './type-check.ts';\n\n/**\n * Sets up the handler to determine if we should advance the tour\n * @param step The step instance\n * @param selector\n * @private\n */\nfunction _setupAdvanceOnHandler(step: Step, selector?: string) {\n  return (event: Event) => {\n    if (step.isOpen()) {\n      const targetIsEl = step.el && event.currentTarget === step.el;\n      const targetIsSelector =\n        !isUndefined(selector) &&\n        (event.currentTarget as HTMLElement).matches(selector);\n\n      if (targetIsSelector || targetIsEl) {\n        step.tour.next();\n      }\n    }\n  };\n}\n\n/**\n * Bind the event handler for advanceOn\n * @param step The step instance\n */\nexport function bindAdvance(step: Step) {\n  // An empty selector matches the step element\n  const { event, selector } = step.options.advanceOn || {};\n  if (event) {\n    const handler = _setupAdvanceOnHandler(step, selector);\n\n    // TODO: this should also bind/unbind on show/hide\n    let el: Element | null = null;\n\n    if (!isUndefined(selector)) {\n      el = document.querySelector(selector);\n\n      if (!el) {\n        return console.error(\n          `No element was found for the selector supplied to advanceOn: ${selector}`\n        );\n      }\n    }\n\n    if (el) {\n      el.addEventListener(event, handler);\n      step.on('destroy', () => {\n        return (el as HTMLElement).removeEventListener(event, handler);\n      });\n    } else {\n      document.body.addEventListener(event, handler, true);\n      step.on('destroy', () => {\n        return document.body.removeEventListener(event, handler, true);\n      });\n    }\n  } else {\n    return console.error(\n      'advanceOn was defined, but no event name was passed.'\n    );\n  }\n}\n", "import { type Tour, type TourOptions } from '../tour.ts';\nimport {\n  type StepOptionsAttachTo,\n  type Step,\n  type StepOptions\n} from '../step.ts';\nimport { isFunction, isString } from './type-check.ts';\n\nexport class StepNoOp {\n  constructor(_options: StepOptions) {}\n}\n\nexport class TourNoOp {\n  constructor(_tour: Tour, _options: TourOptions) {}\n}\n\n/**\n * Ensure class prefix ends in `-`\n * @param prefix - The prefix to prepend to the class names generated by nano-css\n * @return The prefix ending in `-`\n */\nexport function normalizePrefix(prefix?: string) {\n  if (!isString(prefix) || prefix === '') {\n    return '';\n  }\n\n  return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;\n}\n\n/**\n * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n * @param step - The step instance\n * @returns {{}|{element, on}}\n * `element` is a qualified HTML Element\n * `on` is a string position value\n */\nexport function parseAttachTo(step: Step) {\n  const options = step.options.attachTo || {};\n  const returnOpts = Object.assign({}, options);\n\n  if (isFunction(returnOpts.element)) {\n    // Bind the callback to step so that it has access to the object, to enable running additional logic\n    returnOpts.element = returnOpts.element.call(step);\n  }\n\n  if (isString(returnOpts.element)) {\n    // Can't override the element in user opts reference because we can't\n    // guarantee that the element will exist in the future.\n    try {\n      returnOpts.element = document.querySelector(\n        returnOpts.element\n      ) as HTMLElement;\n    } catch (_e) {\n      // TODO\n    }\n    if (!returnOpts.element) {\n      console.error(\n        `The element for this Shepherd step was not found ${options.element}`\n      );\n    }\n  }\n\n  return returnOpts;\n}\n\n/*\n * Resolves the step's `extraHighlights` option, converting any locator values to HTMLElements.\n */\nexport function parseExtraHighlights(step: Step): HTMLElement[] {\n  if (step.options.extraHighlights) {\n    return step.options.extraHighlights.flatMap((highlight) => {\n      return Array.from(document.querySelectorAll(highlight)) as HTMLElement[];\n    });\n  }\n  return [];\n}\n\n/**\n * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n * alternative for the deprecated step.isCentered() method.\n */\nexport function shouldCenterStep(resolvedAttachToOptions: StepOptionsAttachTo) {\n  if (\n    resolvedAttachToOptions === undefined ||\n    resolvedAttachToOptions === null\n  ) {\n    return true;\n  }\n\n  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n}\n\n/**\n * Create a unique id for steps, tours, modals, etc\n */\nexport function uuid() {\n  let d = Date.now();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = ((d + Math.random() * 16) % 16) | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    var _platform$detectOverf;\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: {\n        ...platform,\n        detectOverflow: (_platform$detectOverf = platform.detectOverflow) != null ? _platform$detectOverf : detectOverflow\n      },\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects,\n        platform\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await platform.detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await platform.detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        platform\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await platform.detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n", "import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import { deepmerge } from 'deepmerge-ts';\nimport { shouldCenterStep } from './general.ts';\nimport {\n  autoUpdate,\n  arrow,\n  computePosition,\n  flip,\n  autoPlacement,\n  limitShift,\n  shift,\n  type ComputePositionConfig,\n  type MiddlewareData,\n  type Placement,\n  type Alignment\n} from '@floating-ui/dom';\nimport type { Step, StepOptions, StepOptionsAttachTo } from '../step.ts';\nimport { isHTMLElement } from './type-check.ts';\n\n/**\n * Determines options for the tooltip and initializes event listeners.\n *\n * @param step The step instance\n */\nexport function setupTooltip(step: Step): ComputePositionConfig {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  const attachToOptions = step._getResolvedAttachToOptions();\n\n  let target = attachToOptions.element as HTMLElement;\n  const floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (shouldCenter) {\n    target = document.body;\n    const content = step.shepherdElementComponent?.element;\n    content?.classList.add('shepherd-centered');\n  }\n\n  step.cleanup = autoUpdate(target, step.el as HTMLElement, () => {\n    // The element might have already been removed by the end of the tour.\n    if (!step.el) {\n      step.cleanup?.();\n      return;\n    }\n\n    setPosition(target, step, floatingUIOptions, shouldCenter);\n  });\n\n  step.target = attachToOptions.element as HTMLElement;\n\n  return floatingUIOptions;\n}\n\n/**\n * Merge tooltip options handling nested keys.\n *\n * @param tourOptions - The default tour options.\n * @param options - Step specific options.\n *\n * @return {floatingUIOptions: FloatingUIOptions}\n */\nexport function mergeTooltipConfig(\n  tourOptions: StepOptions,\n  options: StepOptions\n): { floatingUIOptions: ComputePositionConfig } {\n  return {\n    floatingUIOptions: deepmerge(\n      tourOptions.floatingUIOptions || {},\n      options.floatingUIOptions || {}\n    )\n  };\n}\n\n/**\n * Cleanup function called when the step is closed/destroyed.\n *\n * @param step\n */\nexport function destroyTooltip(step: Step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  step.cleanup = null;\n}\n\nfunction setPosition(\n  target: HTMLElement,\n  step: Step,\n  floatingUIOptions: ComputePositionConfig,\n  shouldCenter: boolean\n) {\n  return (\n    computePosition(target, step.el as HTMLElement, floatingUIOptions)\n      .then(floatingUIposition(step, shouldCenter))\n      // Wait before forcing focus.\n      .then(\n        (step: Step) =>\n          new Promise<Step>((resolve) => {\n            setTimeout(() => resolve(step), 300);\n          })\n      )\n      // Replaces focusAfterRender modifier.\n      .then((step: Step) => {\n        if (step?.el) {\n          step.el.tabIndex = 0;\n          step.el.focus({ preventScroll: true });\n        }\n      })\n  );\n}\n\nfunction floatingUIposition(step: Step, shouldCenter: boolean) {\n  return ({\n    x,\n    y,\n    placement,\n    middlewareData\n  }: {\n    x: number;\n    y: number;\n    placement: Placement;\n    middlewareData: MiddlewareData;\n  }) => {\n    if (!step.el) {\n      return step;\n    }\n\n    if (shouldCenter) {\n      Object.assign(step.el.style, {\n        position: 'fixed',\n        left: '50%',\n        top: '50%',\n        transform: 'translate(-50%, -50%)'\n      });\n    } else {\n      Object.assign(step.el.style, {\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    }\n\n    step.el.dataset['popperPlacement'] = placement;\n\n    placeArrow(step.el, middlewareData);\n\n    return step;\n  };\n}\n\nfunction placeArrow(el: HTMLElement, middlewareData: MiddlewareData) {\n  const arrowEl = el.querySelector('.shepherd-arrow');\n  if (isHTMLElement(arrowEl) && middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : '',\n      top: arrowY != null ? `${arrowY}px` : ''\n    });\n  }\n}\n\n/**\n * Gets the `Floating UI` options from a set of base `attachTo` options\n * @param attachToOptions\n * @param step The step instance\n * @private\n */\nexport function getFloatingUIOptions(\n  attachToOptions: StepOptionsAttachTo,\n  step: Step\n): ComputePositionConfig {\n  const options: ComputePositionConfig = {\n    strategy: 'absolute'\n  };\n\n  options.middleware = [];\n\n  const arrowEl = addArrow(step);\n\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  const hasAutoPlacement = attachToOptions.on?.includes('auto');\n\n  const hasEdgeAlignment =\n    attachToOptions?.on?.includes('-start') ||\n    attachToOptions?.on?.includes('-end');\n\n  if (!shouldCenter) {\n    if (hasAutoPlacement) {\n      options.middleware.push(\n        autoPlacement({\n          crossAxis: true,\n          alignment: hasEdgeAlignment\n            ? (attachToOptions?.on?.split('-').pop() as Alignment)\n            : null\n        })\n      );\n    } else {\n      options.middleware.push(flip());\n    }\n\n    options.middleware.push(\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      })\n    );\n\n    if (arrowEl) {\n      const arrowOptions =\n        typeof step.options.arrow === 'object'\n          ? step.options.arrow\n          : { padding: 4 };\n\n      options.middleware.push(\n        arrow({\n          element: arrowEl,\n          padding: hasEdgeAlignment ? arrowOptions.padding : 0\n        })\n      );\n    }\n\n    if (!hasAutoPlacement) options.placement = attachToOptions.on as Placement;\n  }\n\n  return deepmerge(options, step.options.floatingUIOptions || {});\n}\n\nfunction addArrow(step: Step) {\n  if (step.options.arrow && step.el) {\n    return step.el.querySelector('.shepherd-arrow');\n  }\n\n  return false;\n}\n", "type Attrs = Record<string, unknown>;\ntype Child = Node | string | null | undefined | false;\n\n/**\n * Create an HTML element with attributes and children.\n * Attributes starting with \"on\" are added as event listeners.\n * Null/undefined/false attribute values are skipped.\n */\nexport function h(\n  tag: string,\n  attrs?: Attrs | null,\n  ...children: Child[]\n): HTMLElement {\n  const el = document.createElement(tag);\n  applyAttrs(el, attrs);\n  appendChildren(el, children);\n  return el;\n}\n\n/**\n * Create an SVG element with attributes and children.\n */\nexport function svgEl(\n  tag: string,\n  attrs?: Attrs | null,\n  ...children: Child[]\n): SVGElement {\n  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);\n  applyAttrs(el, attrs);\n  appendChildren(el, children);\n  return el;\n}\n\nfunction applyAttrs(el: Element, attrs?: Attrs | null) {\n  if (!attrs) return;\n\n  for (const [key, value] of Object.entries(attrs)) {\n    if (value === null || value === undefined || value === false) continue;\n\n    if (key.startsWith('on') && typeof value === 'function') {\n      el.addEventListener(key.slice(2).toLowerCase(), value as EventListener);\n    } else if (key === 'disabled' && value === true) {\n      (el as HTMLButtonElement).disabled = true;\n    } else {\n      el.setAttribute(key, String(value));\n    }\n  }\n}\n\nfunction appendChildren(el: Element, children: Child[]) {\n  for (const child of children) {\n    if (child != null && child !== false) {\n      el.append(\n        typeof child === 'string' ? document.createTextNode(child) : child\n      );\n    }\n  }\n}\n", "import { h } from '../utils/dom.ts';\nimport { isFunction } from '../utils/type-check.ts';\nimport type { Step, StepOptionsButton } from '../step.ts';\nimport './shepherd-button.css';\n\nfunction getConfigOption(option: unknown, step: Step): unknown {\n  if (isFunction(option)) {\n    return option.call(step);\n  }\n  return option;\n}\n\nexport function createShepherdButton(\n  config: StepOptionsButton,\n  step: Step\n): HTMLButtonElement {\n  const action = config.action ? config.action.bind(step.tour) : null;\n  const disabled = config.disabled\n    ? getConfigOption(config.disabled, step)\n    : false;\n  const label = config.label ? getConfigOption(config.label, step) : null;\n  const text = config.text ? getConfigOption(config.text, step) : null;\n\n  const btn = h('button', {\n    'aria-label': label || null,\n    class: `${config.classes || ''} shepherd-button ${\n      config.secondary ? 'shepherd-button-secondary' : ''\n    }`,\n    disabled: disabled || null,\n    onclick: action,\n    tabindex: '0',\n    type: 'button'\n  }) as HTMLButtonElement;\n\n  if (text) {\n    btn.innerHTML = text as string;\n  }\n\n  return btn;\n}\n", "import { h } from '../utils/dom.ts';\nimport { createShepherdCancelIcon } from './shepherd-cancel-icon.ts';\nimport { createShepherdTitle } from './shepherd-title.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-header.css';\n\nexport function createShepherdHeader(labelId: string, step: Step): HTMLElement {\n  const header = h('header', { class: 'shepherd-header' });\n\n  if (step.options.title) {\n    header.append(createShepherdTitle(labelId, step.options.title));\n  }\n\n  if (step.options.cancelIcon && step.options.cancelIcon.enabled) {\n    header.append(createShepherdCancelIcon(step.options.cancelIcon, step));\n  }\n\n  return header;\n}\n", "import { h } from '../utils/dom.ts';\nimport { isFunction } from '../utils/type-check.ts';\nimport type { StringOrStringFunction } from '../step.ts';\nimport './shepherd-title.css';\n\nexport function createShepherdTitle(\n  labelId: string,\n  title: StringOrStringFunction\n): HTMLHeadingElement {\n  const el = h('h3', {\n    id: labelId,\n    class: 'shepherd-title'\n  }) as HTMLHeadingElement;\n\n  const resolvedTitle = isFunction(title) ? title() : title;\n  el.innerHTML = resolvedTitle;\n\n  return el;\n}\n", "import { h } from '../utils/dom.ts';\nimport type { Step, StepOptionsCancelIcon } from '../step.ts';\nimport './shepherd-cancel-icon.css';\n\nexport function createShepherdCancelIcon(\n  cancelIcon: StepOptionsCancelIcon,\n  step: Step\n): HTMLButtonElement {\n  const handleCancelClick = (e: Event) => {\n    e.preventDefault();\n    step.cancel();\n  };\n\n  const btn = h(\n    'button',\n    {\n      'aria-label': cancelIcon.label ? cancelIcon.label : 'Close Tour',\n      class: 'shepherd-cancel-icon',\n      onclick: handleCancelClick,\n      type: 'button'\n    },\n    h('span', { 'aria-hidden': 'true' }, '\\u00D7')\n  ) as HTMLButtonElement;\n\n  return btn;\n}\n", "import { h } from '../utils/dom.ts';\nimport { createShepherdFooter } from './shepherd-footer.ts';\nimport { createShepherdHeader } from './shepherd-header.ts';\nimport { createShepherdText } from './shepherd-text.ts';\nimport { isUndefined } from '../utils/type-check.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-content.css';\n\nexport function createShepherdContent(\n  descriptionId: string,\n  labelId: string,\n  step: Step\n): HTMLDivElement {\n  const content = h('div', { class: 'shepherd-content' }) as HTMLDivElement;\n\n  if (\n    !isUndefined(step.options.title) ||\n    (step.options.cancelIcon && step.options.cancelIcon.enabled)\n  ) {\n    content.append(createShepherdHeader(labelId, step));\n  }\n\n  if (!isUndefined(step.options.text)) {\n    content.append(createShepherdText(descriptionId, step));\n  }\n\n  if (Array.isArray(step.options.buttons) && step.options.buttons.length) {\n    content.append(createShepherdFooter(step));\n  }\n\n  return content;\n}\n", "import { h } from '../utils/dom.ts';\nimport { isHTMLElement, isFunction } from '../utils/type-check.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-text.css';\n\nexport function createShepherdText(\n  descriptionId: string,\n  step: Step\n): HTMLDivElement {\n  const el = h('div', {\n    class: 'shepherd-text',\n    id: descriptionId\n  }) as HTMLDivElement;\n\n  let text = step.options.text;\n\n  if (isFunction(text)) {\n    text = text.call(step);\n  }\n\n  if (isHTMLElement(text)) {\n    el.appendChild(text);\n  } else {\n    el.innerHTML = text as string;\n  }\n\n  return el;\n}\n", "import { h } from '../utils/dom.ts';\nimport { createShepherdButton } from './shepherd-button.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-footer.css';\n\nexport function createShepherdFooter(step: Step): HTMLElement {\n  const footer = h('footer', { class: 'shepherd-footer' });\n\n  if (step.options.buttons) {\n    for (const config of step.options.buttons) {\n      footer.append(createShepherdButton(config, step));\n    }\n  }\n\n  return footer;\n}\n", "import { deepmerge } from 'deepmerge-ts';\nimport { Evented } from './evented.ts';\nimport autoBind from './utils/auto-bind.ts';\nimport {\n  isElement,\n  isHTMLElement,\n  isFunction,\n  isUndefined\n} from './utils/type-check.ts';\nimport { bindAdvance } from './utils/bind.ts';\nimport {\n  parseAttachTo,\n  normalizePrefix,\n  uuid,\n  parseExtraHighlights\n} from './utils/general.ts';\nimport {\n  setupTooltip,\n  destroyTooltip,\n  mergeTooltipConfig\n} from './utils/floating-ui.ts';\nimport {\n  createShepherdElement,\n  type ShepherdElementResult\n} from './components/shepherd-element.ts';\nimport { type Tour } from './tour.ts';\nimport type { ComputePositionConfig } from '@floating-ui/dom';\n\nexport type StepText =\n  | string\n  | ReadonlyArray<string>\n  | HTMLElement\n  | (() => string | ReadonlyArray<string> | HTMLElement);\n\nexport type StringOrStringFunction = string | (() => string);\n\n/**\n * The options for the step\n */\nexport interface StepOptions {\n  /**\n   * The element the step should be attached to on the page.\n   * An object with properties `element` and `on`.\n   *\n   * ```js\n   * const step = new Step(tour, {\n   *   attachTo: { element: '.some .selector-path', on: 'left' },\n   *   ...moreOptions\n   * });\n   * ```\n   *\n   * If you dont specify an attachTo the element will appear in the middle of the screen.\n   * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n   * in the middle of the screen, without an arrow pointing to the target.\n   */\n  attachTo?: StepOptionsAttachTo;\n\n  /**\n   * An action on the page which should advance shepherd to the next step.\n   * It should be an object with a string `selector` and an `event` name\n   * ```js\n   * const step = new Step(tour, {\n   *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n   *   ...moreOptions\n   * });\n   * ```\n   * `event` doesnt have to be an event inside the tour, it can be any event fired on any element on the page.\n   * You can also always manually advance the Tour by calling `myTour.next()`.\n   */\n  advanceOn?: StepOptionsAdvanceOn;\n\n  /**\n   * Whether to display the arrow for the tooltip or not, or options for the arrow.\n   */\n  arrow?: boolean | StepOptionsArrow;\n\n  /**\n   * A function that returns a promise.\n   * When the promise resolves, the rest of the `show` code for the step will execute.\n   */\n  beforeShowPromise?: () => Promise<unknown>;\n\n  /**\n   * An array of buttons to add to the step. These will be rendered in a\n   * footer below the main body text.\n   */\n  buttons?: ReadonlyArray<StepOptionsButton>;\n\n  /**\n   * Should a cancel  be shown in the header of the step?\n   */\n  cancelIcon?: StepOptionsCancelIcon;\n\n  /**\n   * A boolean, that when set to false, will set `pointer-events: none` on the target.\n   */\n  canClickTarget?: boolean;\n\n  /**\n   * A string of extra classes to add to the step's content element.\n   */\n  classes?: string;\n\n  /**\n   * An array of extra element selectors to highlight when the overlay is shown\n   * The tooltip won't be fixed to these elements, but they will be highlighted\n   * just like the `attachTo` element.\n   * ```js\n   * const step = new Step(tour, {\n   *   extraHighlights: [ '.pricing', '#docs' ],\n   *   ...moreOptions\n   * });\n   * ```\n   */\n  extraHighlights?: ReadonlyArray<string>;\n\n  /**\n   * An extra class to apply to the `attachTo` element when it is\n   * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n   */\n  highlightClass?: string;\n\n  /**\n   * The string to use as the `id` for the step.\n   */\n  id?: string;\n\n  /**\n   * An amount of padding to add around the modal overlay opening\n   */\n  modalOverlayOpeningPadding?: number;\n\n  /**\n   * An amount of border radius to add around the modal overlay opening\n   */\n  modalOverlayOpeningRadius?:\n    | number\n    | {\n        topLeft?: number;\n        bottomLeft?: number;\n        bottomRight?: number;\n        topRight?: number;\n      };\n\n  /**\n   * An amount to offset the modal overlay opening in the x-direction\n   */\n  modalOverlayOpeningXOffset?: number;\n\n  /**\n   * An amount to offset the modal overlay opening in the y-direction\n   */\n  modalOverlayOpeningYOffset?: number;\n\n  /**\n   * Extra [options to pass to FloatingUI]{@link https://floating-ui.com/docs/tutorial/}\n   */\n  floatingUIOptions?: ComputePositionConfig;\n\n  /**\n   * Should the element be scrolled to when this step is shown?\n   */\n  scrollTo?: boolean | ScrollIntoViewOptions;\n\n  /**\n   * A function that lets you override the default scrollTo behavior and\n   * define a custom action to do the scrolling, and possibly other logic.\n   */\n  scrollToHandler?: (element: HTMLElement) => void;\n\n  /**\n   * A function that, when it returns `true`, will show the step.\n   * If it returns `false`, the step will be skipped.\n   */\n  showOn?: () => boolean;\n\n  /**\n   * The text in the body of the step. It can be one of four types:\n   * ```\n   * - HTML string\n   * - Array of HTML strings\n   * - `HTMLElement` object\n   * - `Function` to be executed when the step is built. It must return one of the three options above.\n   * ```\n   */\n  text?: StepText;\n\n  /**\n   * The step's title. It becomes an `h3` at the top of the step.\n   * ```\n   * - HTML string\n   * - `Function` to be executed when the step is built. It must return HTML string.\n   * ```\n   */\n  title?: StringOrStringFunction;\n\n  /**\n   * You can define `show`, `hide`, etc events inside `when`. For example:\n   * ```js\n   * when: {\n   *   show: function() {\n   *     window.scrollTo(0, 0);\n   *   }\n   * }\n   * ```\n   */\n  when?: StepOptionsWhen;\n}\n\nexport type PopperPlacement =\n  | 'auto'\n  | 'auto-start'\n  | 'auto-end'\n  | 'top'\n  | 'top-start'\n  | 'top-end'\n  | 'bottom'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right'\n  | 'right-start'\n  | 'right-end'\n  | 'left'\n  | 'left-start'\n  | 'left-end';\n\nexport interface StepOptionsArrow {\n  /*\n   * The padding from the edge for the arrow.\n   * Not used if this is not a -start or -end placement.\n   */\n  padding?: number;\n}\n\nexport interface StepOptionsAttachTo {\n  element?:\n    | HTMLElement\n    | string\n    | null\n    | (() => HTMLElement | string | null | undefined);\n  on?: PopperPlacement;\n}\n\nexport interface StepOptionsAdvanceOn {\n  event: string;\n  selector: string;\n}\n\nexport interface StepOptionsButton {\n  /**\n   * A function executed when the button is clicked on\n   * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n   * work inside the action.\n   * You can use action to skip steps or navigate to specific steps, with something like:\n   * ```js\n   * action() {\n   *   return this.show('some_step_name');\n   * }\n   * ```\n   */\n  action?: (this: Tour) => void;\n\n  /**\n   * Extra classes to apply to the `<a>`\n   */\n  classes?: string;\n\n  /**\n   * Whether the button should be disabled\n   * When the value is `true`, or the function returns `true` the button will be disabled\n   */\n  disabled?: boolean | (() => boolean);\n\n  /**\n   * The aria-label text of the button\n   */\n  label?: StringOrStringFunction;\n\n  /**\n   * A boolean, that when true, adds a `shepherd-button-secondary` class to the button.\n   */\n  secondary?: boolean;\n\n  /**\n   * The HTML text of the button\n   */\n  text?: StringOrStringFunction;\n}\n\nexport interface StepOptionsButtonEvent {\n  [key: string]: () => void;\n}\n\nexport interface StepOptionsCancelIcon {\n  enabled?: boolean;\n  label?: string;\n}\n\nexport interface StepOptionsWhen {\n  [key: string]: (this: Step) => void;\n}\n\n/**\n * A class representing steps to be added to a tour.\n * @extends {Evented}\n */\nexport class Step extends Evented {\n  _resolvedAttachTo: StepOptionsAttachTo | null;\n  _resolvedExtraHighlightElements?: HTMLElement[];\n  _originalTabIndexes: Map<Element, string>;\n  classPrefix?: string;\n  declare cleanup: Function | null;\n  el?: HTMLElement | null;\n  declare id: string;\n  declare options: StepOptions;\n  shepherdElementComponent?: ShepherdElementResult;\n  target?: HTMLElement | null;\n  tour: Tour;\n\n  constructor(tour: Tour, options: StepOptions = {}) {\n    super();\n\n    this.tour = tour;\n    this.classPrefix = this.tour.options\n      ? normalizePrefix(this.tour.options.classPrefix)\n      : '';\n    // @ts-expect-error TODO: investigate where styles comes from\n    this.styles = tour.styles;\n\n    /**\n     * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n     * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n     * @type {StepOptionsAttachTo | null}\n     * @private\n     */\n    this._resolvedAttachTo = null;\n\n    /**\n     * Map to store original tabIndex values of elements that are modified during the tour.\n     * @type {Map<Element, string | null>}\n     * @private\n     */\n    this._originalTabIndexes = new Map();\n\n    autoBind(this);\n\n    this._setOptions(options);\n\n    return this;\n  }\n\n  /**\n   * Cancel the tour\n   * Triggers the `cancel` event\n   */\n  cancel() {\n    this.tour.cancel();\n    this.trigger('cancel');\n  }\n\n  /**\n   * Complete the tour\n   * Triggers the `complete` event\n   */\n  complete() {\n    this.tour.complete();\n    this.trigger('complete');\n  }\n\n  /**\n   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n   * Triggers `destroy` event\n   */\n  destroy() {\n    this._teardownElements();\n    this.trigger('destroy');\n  }\n\n  /**\n   * Internal cleanup that tears down the tooltip, component, and DOM element\n   * without emitting the public \"destroy\" event.\n   * @private\n   */\n  _teardownElements() {\n    destroyTooltip(this);\n\n    if (this.shepherdElementComponent) {\n      this.shepherdElementComponent.cleanup();\n      this.shepherdElementComponent = undefined;\n    }\n\n    if (isHTMLElement(this.el)) {\n      this.el.remove();\n      this.el = null;\n    }\n\n    this._updateStepTargetOnHide();\n    this._originalTabIndexes.clear();\n  }\n\n  /**\n   * Returns the tour for the step\n   * @return The tour instance\n   */\n  getTour() {\n    return this.tour;\n  }\n\n  /**\n   * Hide the step\n   */\n  hide() {\n    this.tour.modal?.hide();\n\n    this.trigger('before-hide');\n\n    if (this.el) {\n      this.el.hidden = true;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('hide');\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   */\n  _resolveExtraHiglightElements() {\n    this._resolvedExtraHighlightElements = parseExtraHighlights(this);\n    return this._resolvedExtraHighlightElements;\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   */\n  _resolveAttachToOptions() {\n    this._resolvedAttachTo = parseAttachTo(this);\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * A selector for resolved attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _getResolvedAttachToOptions() {\n    if (this._resolvedAttachTo === null) {\n      return this._resolveAttachToOptions();\n    }\n\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * Check if the step is open and visible\n   * @return True if the step is open and visible\n   */\n  isOpen() {\n    return Boolean(this.el && !this.el.hidden);\n  }\n\n  /**\n   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n   */\n  show() {\n    if (isFunction(this.options.beforeShowPromise)) {\n      return Promise.resolve(this.options.beforeShowPromise()).then(() =>\n        this._show()\n      );\n    }\n    return Promise.resolve(this._show());\n  }\n\n  /**\n   * Updates the options of the step.\n   *\n   * @param {StepOptions} options The options for the step\n   */\n  updateStepOptions(options: StepOptions) {\n    Object.assign(this.options, options);\n\n    if (this.shepherdElementComponent) {\n      // Recreate the element with updated options\n      if (this.el) {\n        this._teardownElements();\n        this._setupElements();\n      }\n    }\n  }\n\n  /**\n   * Returns the element for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n   */\n  getElement() {\n    return this.el;\n  }\n\n  /**\n   * Returns the target for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n   */\n  getTarget() {\n    return this.target;\n  }\n\n  /**\n   * Stores the original tabIndex value of an element before modifying it.\n   * Only stores the value if the element has a tabindex attribute.\n   * @param {Element} element The element whose tabIndex will be stored\n   * @private\n   */\n  _storeOriginalTabIndex(element: Element): void {\n    const originalValue = element.getAttribute('tabindex');\n    if (originalValue !== null) {\n      this._originalTabIndexes.set(element, originalValue);\n    }\n  }\n\n  /**\n   * Restores the original tabIndex values for all elements that were modified during the tour.\n   * If an element is in the map, restores its original value.\n   * If an element is not in the map, removes the tabindex attribute (it didn't have one originally).\n   * Note: Does not clear the map to allow for multiple show/hide cycles.\n   * @private\n   */\n  _restoreOriginalTabIndexes(): void {\n    const target = this.target;\n    if (target) {\n      if (this._originalTabIndexes.has(target)) {\n        target.setAttribute('tabindex', this._originalTabIndexes.get(target)!);\n      } else {\n        target.removeAttribute('tabindex');\n      }\n    }\n  }\n\n  /**\n   * Creates Shepherd element for step based on options\n   *\n   * @return {HTMLElement} The DOM element for the step tooltip\n   * @private\n   */\n  _createTooltipContent() {\n    const descriptionId = `${this.id}-description`;\n    const labelId = `${this.id}-label`;\n\n    this.shepherdElementComponent = createShepherdElement({\n      classPrefix: this.classPrefix,\n      descriptionId,\n      labelId,\n      step: this\n    });\n\n    const target = this.tour.options.stepsContainer || document.body;\n    target.append(this.shepherdElementComponent.element);\n\n    return this.shepherdElementComponent.element;\n  }\n\n  /**\n   * If a custom scrollToHandler is defined, call that, otherwise do the generic\n   * scrollIntoView call.\n   *\n   * @param {boolean | ScrollIntoViewOptions} scrollToOptions - If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n   * @private\n   */\n  _scrollTo(scrollToOptions: boolean | ScrollIntoViewOptions) {\n    const { element } = this._getResolvedAttachToOptions();\n\n    if (isFunction(this.options.scrollToHandler)) {\n      this.options.scrollToHandler(element as HTMLElement);\n    } else if (\n      isElement(element) &&\n      typeof element.scrollIntoView === 'function'\n    ) {\n      element.scrollIntoView(scrollToOptions);\n    }\n  }\n\n  /**\n   * _getClassOptions gets all possible classes for the step\n   * @param {StepOptions} stepOptions The step specific options\n   * @returns {string} unique string from array of classes\n   */\n  _getClassOptions(stepOptions: StepOptions) {\n    const defaultStepOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n    const stepClasses = stepOptions.classes ? stepOptions.classes : '';\n    const defaultStepOptionsClasses =\n      defaultStepOptions && defaultStepOptions.classes\n        ? defaultStepOptions.classes\n        : '';\n    const allClasses = [\n      ...stepClasses.split(' '),\n      ...defaultStepOptionsClasses.split(' ')\n    ];\n    const uniqClasses = new Set(allClasses);\n\n    return Array.from(uniqClasses).join(' ').trim();\n  }\n\n  /**\n   * Sets the options for the step, maps `when` to events, sets up buttons\n   * @param options - The options for the step\n   */\n  _setOptions(options: StepOptions = {}) {\n    let tourOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n\n    tourOptions = deepmerge({}, tourOptions || {});\n\n    this.options = Object.assign(\n      {\n        arrow: true\n      },\n      tourOptions,\n      options,\n      mergeTooltipConfig(tourOptions, options)\n    );\n\n    const { when } = this.options;\n\n    this.options.classes = this._getClassOptions(options);\n\n    this.destroy();\n    this.id = this.options.id || `step-${uuid()}`;\n\n    if (when) {\n      Object.keys(when).forEach((event) => {\n        // @ts-expect-error TODO: fix this type error\n        this.on(event, when[event], this);\n      });\n    }\n  }\n\n  /**\n   * Create the element and set up the FloatingUI instance\n   * @private\n   */\n  _setupElements() {\n    if (!isUndefined(this.el)) {\n      this.destroy();\n    }\n\n    this.el = this._createTooltipContent();\n\n    if (this.options.advanceOn) {\n      bindAdvance(this);\n    }\n\n    // The tooltip implementation details are handled outside of the Step\n    // object.\n    setupTooltip(this);\n  }\n\n  /**\n   * Triggers `before-show`, generates the tooltip DOM content,\n   * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n   * @private\n   */\n  _show() {\n    this.trigger('before-show');\n\n    // Force resolve to make sure the options are updated on subsequent shows.\n    this._resolveAttachToOptions();\n    this._resolveExtraHiglightElements();\n    this._setupElements();\n\n    if (!this.tour.modal) {\n      this.tour.setupModal();\n    }\n\n    this.tour.modal?.setupForStep(this);\n    this._styleTargetElementForStep(this);\n\n    if (this.el) {\n      this.el.hidden = false;\n    }\n\n    // start scrolling to target before showing the step\n    if (this.options.scrollTo) {\n      setTimeout(() => {\n        this._scrollTo(\n          this.options.scrollTo as boolean | ScrollIntoViewOptions\n        );\n      });\n    }\n\n    if (this.el) {\n      this.el.hidden = false;\n    }\n\n    const content = this.shepherdElementComponent!.element;\n    const target = this.target || document.body;\n    const extraHighlightElements = this._resolvedExtraHighlightElements;\n\n    target.classList.add(`${this.classPrefix}shepherd-enabled`);\n    target.classList.add(`${this.classPrefix}shepherd-target`);\n    content.classList.add('shepherd-enabled');\n\n    extraHighlightElements?.forEach((el) => {\n      el.classList.add(`${this.classPrefix}shepherd-enabled`);\n      el.classList.add(`${this.classPrefix}shepherd-target`);\n    });\n\n    this.trigger('show');\n  }\n\n  /**\n   * Modulates the styles of the passed step's target element, based on the step's options and\n   * the tour's `modal` option, to visually emphasize the element\n   *\n   * @param {Step} step The step object that attaches to the element\n   * @private\n   */\n  _styleTargetElementForStep(step: Step) {\n    const targetElement = step.target;\n    const extraHighlightElements = step._resolvedExtraHighlightElements;\n\n    if (!targetElement) {\n      return;\n    }\n\n    const highlightClass = step.options.highlightClass;\n    if (highlightClass) {\n      targetElement.classList.add(highlightClass);\n      extraHighlightElements?.forEach((el) => el.classList.add(highlightClass));\n    }\n\n    targetElement.classList.remove('shepherd-target-click-disabled');\n    extraHighlightElements?.forEach((el) =>\n      el.classList.remove('shepherd-target-click-disabled')\n    );\n\n    if (step.options.canClickTarget === false) {\n      targetElement.classList.add('shepherd-target-click-disabled');\n      extraHighlightElements?.forEach((el) =>\n        el.classList.add('shepherd-target-click-disabled')\n      );\n    }\n  }\n\n  /**\n   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n   * and 'shepherd-target' classes\n   * @private\n   */\n  _updateStepTargetOnHide() {\n    const target = this.target || document.body;\n    const extraHighlightElements = this._resolvedExtraHighlightElements;\n\n    const highlightClass = this.options.highlightClass;\n    if (highlightClass) {\n      target.classList.remove(highlightClass);\n      extraHighlightElements?.forEach((el) =>\n        el.classList.remove(highlightClass)\n      );\n    }\n\n    target.classList.remove(\n      'shepherd-target-click-disabled',\n      `${this.classPrefix}shepherd-enabled`,\n      `${this.classPrefix}shepherd-target`\n    );\n    extraHighlightElements?.forEach((el) => {\n      el.classList.remove(\n        'shepherd-target-click-disabled',\n        `${this.classPrefix}shepherd-enabled`,\n        `${this.classPrefix}shepherd-target`\n      );\n    });\n\n    this._restoreOriginalTabIndexes();\n  }\n}\n", "import { h } from '../utils/dom.ts';\nimport { createShepherdContent } from './shepherd-content.ts';\nimport { isUndefined, isString } from '../utils/type-check.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-element.css';\n\nconst KEY_TAB = 9;\nconst KEY_ESC = 27;\nconst LEFT_ARROW = 37;\nconst RIGHT_ARROW = 39;\n\nexport interface ShepherdElementOptions {\n  classPrefix?: string;\n  descriptionId: string;\n  labelId: string;\n  step: Step;\n}\n\nexport interface ShepherdElementResult {\n  element: HTMLDialogElement;\n  cleanup: () => void;\n}\n\nexport function createShepherdElement(\n  options: ShepherdElementOptions\n): ShepherdElementResult {\n  const { classPrefix, descriptionId, labelId, step } = options;\n\n  let attachToElement: HTMLElement | null | undefined;\n\n  // Focusable attachTo elements\n  let focusableAttachToElements: Element[] | undefined;\n  let firstFocusableAttachToElement: Element | undefined;\n  let lastFocusableAttachToElement: Element | undefined;\n\n  // Focusable dialog elements\n  let firstFocusableDialogElement: Element | undefined;\n  let focusableDialogElements: Element[] | undefined;\n  let lastFocusableDialogElement: Element | undefined;\n\n  const hasCancelIcon = step.options?.cancelIcon?.enabled ?? false;\n  const hasTitle = step.options?.title ?? false;\n\n  /**\n   * Setup keydown events to allow closing the modal with ESC\n   *\n   * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n   */\n  const handleKeyDown = (e: KeyboardEvent) => {\n    const { tour } = step;\n    switch (e.keyCode) {\n      case KEY_TAB:\n        if (\n          (!focusableAttachToElements ||\n            focusableAttachToElements.length === 0) &&\n          focusableDialogElements &&\n          focusableDialogElements.length === 0\n        ) {\n          e.preventDefault();\n          break;\n        }\n        // Backward tab\n        if (e.shiftKey) {\n          if (\n            document.activeElement === firstFocusableDialogElement ||\n            document.activeElement?.classList.contains('shepherd-element')\n          ) {\n            e.preventDefault();\n            (\n              (lastFocusableAttachToElement ??\n                lastFocusableDialogElement) as HTMLElement\n            )?.focus();\n          } else if (document.activeElement === firstFocusableAttachToElement) {\n            e.preventDefault();\n            (lastFocusableDialogElement as HTMLElement)?.focus();\n          }\n        } else {\n          if (document.activeElement === lastFocusableDialogElement) {\n            e.preventDefault();\n            (\n              (firstFocusableAttachToElement ??\n                firstFocusableDialogElement) as HTMLElement\n            )?.focus();\n          } else if (document.activeElement === lastFocusableAttachToElement) {\n            e.preventDefault();\n            (firstFocusableDialogElement as HTMLElement)?.focus();\n          }\n        }\n        break;\n      case KEY_ESC:\n        if (tour.options.exitOnEsc) {\n          e.preventDefault();\n          e.stopPropagation();\n          step.cancel();\n        }\n        break;\n      case LEFT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.preventDefault();\n          e.stopPropagation();\n          tour.back();\n        }\n        break;\n      case RIGHT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.preventDefault();\n          e.stopPropagation();\n          tour.next();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n\n  // Build the dialog element\n  const element = h('dialog', {\n    'aria-describedby': !isUndefined(step.options.text) ? descriptionId : null,\n    'aria-labelledby': step.options.title ? labelId : null,\n    class: [\n      'shepherd-element',\n      hasCancelIcon ? 'shepherd-has-cancel-icon' : '',\n      hasTitle ? 'shepherd-has-title' : ''\n    ]\n      .filter(Boolean)\n      .join(' '),\n    [`data-${classPrefix}shepherd-step-id`]: step.id,\n    onkeydown: handleKeyDown,\n    open: 'true'\n  }) as HTMLDialogElement;\n\n  // Add arrow if needed\n  if (\n    step.options.arrow &&\n    step.options.attachTo &&\n    step.options.attachTo.element &&\n    step.options.attachTo.on\n  ) {\n    element.append(\n      h('div', { class: 'shepherd-arrow', 'data-popper-arrow': '' })\n    );\n  }\n\n  // Add content\n  element.append(createShepherdContent(descriptionId, labelId, step));\n\n  // Dynamic class management\n  if (isString(step.options.classes)) {\n    const classes = step.options.classes.split(' ').filter((c) => !!c.length);\n    if (classes.length) {\n      element.classList.add(...classes);\n    }\n  }\n\n  // Setup focusable element tracking (equivalent of onMount)\n  const focusableSelector =\n    'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]';\n\n  focusableDialogElements = [...element.querySelectorAll(focusableSelector)];\n  firstFocusableDialogElement = focusableDialogElements[0];\n  lastFocusableDialogElement =\n    focusableDialogElements[focusableDialogElements.length - 1];\n\n  const attachTo = step._getResolvedAttachToOptions();\n  if (attachTo?.element) {\n    attachToElement = attachTo.element as HTMLElement;\n    step._storeOriginalTabIndex(attachToElement);\n    attachToElement.tabIndex = 0;\n    focusableAttachToElements = [\n      attachToElement,\n      ...attachToElement.querySelectorAll(focusableSelector)\n    ];\n    firstFocusableAttachToElement = focusableAttachToElements[0];\n    lastFocusableAttachToElement =\n      focusableAttachToElements[focusableAttachToElements.length - 1];\n    attachToElement.addEventListener('keydown', handleKeyDown);\n  }\n\n  const cleanup = () => {\n    attachToElement?.removeEventListener('keydown', handleKeyDown);\n  };\n\n  return { element, cleanup };\n}\n", "import { svgEl } from '../utils/dom.ts';\nimport { makeOverlayPath } from '../utils/overlay-path.ts';\nimport type { Step } from '../step.ts';\nimport './shepherd-modal.css';\n\ninterface OpeningProperty {\n  width: number;\n  height: number;\n  x: number;\n  y: number;\n  r:\n    | number\n    | {\n        topLeft: number;\n        bottomLeft: number;\n        bottomRight: number;\n        topRight: number;\n      };\n}\n\ntype ModalRadiusType =\n  | number\n  | {\n      topLeft?: number;\n      bottomLeft?: number;\n      bottomRight?: number;\n      topRight?: number;\n    };\n\nexport interface ShepherdModalAPI {\n  closeModalOpening: () => void;\n  destroy: () => void;\n  hide: () => void;\n  positionModal: (\n    modalOverlayOpeningPadding?: number,\n    modalOverlayOpeningRadius?: ModalRadiusType,\n    modalOverlayOpeningXOffset?: number,\n    modalOverlayOpeningYOffset?: number,\n    scrollParent?: HTMLElement | null,\n    targetElement?: HTMLElement | null,\n    extraHighlights?: HTMLElement[]\n  ) => void;\n  setupForStep: (step: Step) => void;\n  show: () => void;\n  getElement: () => SVGElement;\n}\n\nexport function createShepherdModal(container: HTMLElement): ShepherdModalAPI {\n  let rafId: number | undefined;\n  let openingProperties: OpeningProperty[] = [\n    { width: 0, height: 0, x: 0, y: 0, r: 0 }\n  ];\n\n  // Build SVG elements\n  const pathEl = svgEl('path');\n  const element = svgEl(\n    'svg',\n    { class: 'shepherd-modal-overlay-container' },\n    pathEl\n  );\n\n  element.addEventListener('touchmove', _preventModalOverlayTouch);\n\n  // Initial render\n  _updatePath();\n\n  container.append(element);\n\n  function _updatePath() {\n    pathEl.setAttribute('d', makeOverlayPath(openingProperties));\n  }\n\n  function closeModalOpening() {\n    openingProperties = [{ width: 0, height: 0, x: 0, y: 0, r: 0 }];\n    _updatePath();\n  }\n\n  function hide() {\n    element.classList.remove('shepherd-modal-is-visible');\n    _cleanupStepEventListeners();\n  }\n\n  function show() {\n    element.classList.add('shepherd-modal-is-visible');\n  }\n\n  function positionModal(\n    modalOverlayOpeningPadding = 0,\n    modalOverlayOpeningRadius: ModalRadiusType = 0,\n    modalOverlayOpeningXOffset = 0,\n    modalOverlayOpeningYOffset = 0,\n    scrollParent?: HTMLElement | null,\n    targetElement?: HTMLElement | null,\n    extraHighlights?: HTMLElement[]\n  ) {\n    if (targetElement) {\n      const elementsToHighlight = [targetElement, ...(extraHighlights || [])];\n      const newOpenings: OpeningProperty[] = [];\n\n      for (const el of elementsToHighlight) {\n        if (!el) continue;\n\n        // Skip duplicate elements\n        if (\n          elementsToHighlight.indexOf(el) !==\n          elementsToHighlight.lastIndexOf(el)\n        ) {\n          continue;\n        }\n\n        const { y, height } = _getVisibleHeight(el, scrollParent);\n        const { x, width, left } = el.getBoundingClientRect();\n\n        // Check if the element is contained by another element.\n        // Use _getVisibleHeight for otherElement too so both sides\n        // compare scroll-clipped geometry on the y-axis.\n        const isContained = elementsToHighlight.some((otherElement) => {\n          if (otherElement === el) return false;\n          const otherRect = otherElement.getBoundingClientRect();\n          const { y: otherY, height: otherHeight } = _getVisibleHeight(\n            otherElement,\n            scrollParent\n          );\n          return (\n            x >= otherRect.left &&\n            x + width <= otherRect.left + otherRect.width &&\n            y >= otherY &&\n            y + height <= otherY + otherHeight\n          );\n        });\n\n        if (isContained) continue;\n\n        newOpenings.push({\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x:\n            (x || left) +\n            modalOverlayOpeningXOffset -\n            modalOverlayOpeningPadding,\n          y: y + modalOverlayOpeningYOffset - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius as OpeningProperty['r']\n        });\n      }\n\n      openingProperties = newOpenings;\n    } else {\n      closeModalOpening();\n      return;\n    }\n\n    _updatePath();\n  }\n\n  function setupForStep(step: Step) {\n    _cleanupStepEventListeners();\n\n    if (step.tour.options.useModalOverlay) {\n      _styleForStep(step);\n      show();\n    } else {\n      hide();\n    }\n  }\n\n  function destroy() {\n    _cleanupStepEventListeners();\n    element.removeEventListener('touchmove', _preventModalOverlayTouch);\n    element.remove();\n  }\n\n  function getElement() {\n    return element;\n  }\n\n  // --- Private helpers ---\n\n  function _preventModalOverlayTouch(e: Event) {\n    e.stopPropagation();\n  }\n\n  const _preventModalBodyTouch = (e: Event) => {\n    e.preventDefault();\n  };\n\n  function _addStepEventListeners() {\n    window.addEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  function _cleanupStepEventListeners() {\n    if (rafId) {\n      cancelAnimationFrame(rafId);\n      rafId = undefined;\n    }\n\n    window.removeEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    } as EventListenerOptions);\n  }\n\n  function _styleForStep(step: Step) {\n    const {\n      modalOverlayOpeningPadding,\n      modalOverlayOpeningRadius,\n      modalOverlayOpeningXOffset = 0,\n      modalOverlayOpeningYOffset = 0\n    } = step.options;\n\n    const iframeOffset = _getIframeOffset(step.target);\n    const scrollParent = _getScrollParent(step.target);\n\n    const rafLoop = () => {\n      rafId = undefined;\n      positionModal(\n        modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius,\n        modalOverlayOpeningXOffset + iframeOffset.left,\n        modalOverlayOpeningYOffset + iframeOffset.top,\n        scrollParent,\n        step.target,\n        step._resolvedExtraHighlightElements\n      );\n      rafId = requestAnimationFrame(rafLoop);\n    };\n\n    rafLoop();\n    _addStepEventListeners();\n  }\n\n  function _getScrollParent(el?: HTMLElement | null): HTMLElement | null {\n    if (!el) return null;\n\n    const isHtmlElement = el instanceof HTMLElement;\n    const overflowY = isHtmlElement && window.getComputedStyle(el).overflowY;\n    const isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n\n    if (isScrollable && el.scrollHeight >= el.clientHeight) {\n      return el;\n    }\n\n    return _getScrollParent(el.parentElement);\n  }\n\n  function _getIframeOffset(el?: HTMLElement | null) {\n    const offset = { top: 0, left: 0 };\n\n    if (!el) return offset;\n\n    let targetWindow: Window | null = el.ownerDocument.defaultView;\n\n    try {\n      while (targetWindow && targetWindow !== window.top) {\n        const targetIframe = targetWindow?.frameElement;\n\n        if (targetIframe) {\n          const rect = targetIframe.getBoundingClientRect();\n          offset.top += rect.top + targetIframe.scrollTop;\n          offset.left += rect.left + targetIframe.scrollLeft;\n        }\n\n        targetWindow = targetWindow.parent;\n      }\n    } catch {\n      // Cross-origin iframe  stop traversal and use the offset accumulated so far.\n    }\n\n    return offset;\n  }\n\n  function _getVisibleHeight(\n    el: HTMLElement,\n    scrollParent?: HTMLElement | null\n  ) {\n    const elementRect = el.getBoundingClientRect();\n    let top = elementRect.y || elementRect.top;\n    let bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      const scrollRect = scrollParent.getBoundingClientRect();\n      const scrollTop = scrollRect.y || scrollRect.top;\n      const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    const height = Math.max(bottom - top, 0);\n    return { y: top, height };\n  }\n\n  return {\n    closeModalOpening,\n    destroy,\n    hide,\n    positionModal,\n    setupForStep,\n    show,\n    getElement\n  };\n}\n", "interface OverlayPathParams {\n  height: number;\n  r?:\n    | number\n    | {\n        bottomLeft: number;\n        bottomRight: number;\n        topLeft: number;\n        topRight: number;\n      };\n  x?: number;\n  y?: number;\n  width: number;\n}\n/**\n * Generates the svg path data for a rounded rectangle overlay\n * @param dimension - Dimensions of rectangle.\n * @param dimension.width - Width.\n * @param dimension.height - Height.\n * @param dimension.x - Offset from top left corner in x axis. default 0.\n * @param dimension.y - Offset from top left corner in y axis. default 0.\n * @param dimension.r - Corner Radius. Keep this smaller than half of width or height.\n * @returns Rounded rectangle overlay path data.\n */\nexport function makeOverlayPath(overlayPaths: OverlayPathParams[]) {\n  let openings = '';\n\n  const { innerWidth: w, innerHeight: h } = window;\n\n  overlayPaths.forEach((overlayPath) => {\n    const { width, height, x = 0, y = 0, r = 0 } = overlayPath;\n    const {\n      topLeft = 0,\n      topRight = 0,\n      bottomRight = 0,\n      bottomLeft = 0\n    } = typeof r === 'number'\n      ? { topLeft: r, topRight: r, bottomRight: r, bottomLeft: r }\n      : r;\n\n    openings += `M${x + topLeft},${y}\\\n      a${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}\\\n      V${height + y - bottomLeft}\\\n      a${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}\\\n      H${width + x - bottomRight}\\\n      a${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}\\\n      V${y + topRight}\\\n      a${topRight},${topRight},0,0,0-${topRight}-${topRight}\\\n      Z`;\n  });\n\n  return `M${w},${h}\\\n          H0\\\n          V0\\\n          H${w}\\\n          V${h}\\\n          Z\\\n          ${openings}`.replace(/\\s/g, '');\n}\n", "import { Evented } from './evented.ts';\nimport { Step, type StepOptions } from './step.ts';\nimport autoBind from './utils/auto-bind.ts';\nimport {\n  isHTMLElement,\n  isFunction,\n  isString,\n  isUndefined\n} from './utils/type-check.ts';\nimport { cleanupSteps } from './utils/cleanup.ts';\nimport { normalizePrefix, uuid } from './utils/general.ts';\nimport {\n  createShepherdModal,\n  type ShepherdModalAPI\n} from './components/shepherd-modal.ts';\n\nexport interface EventOptions {\n  previous?: Step | null;\n  step?: Step | null;\n  tour: Tour;\n}\n\nexport type TourConfirmCancel =\n  | boolean\n  | (() => boolean)\n  | Promise<boolean>\n  | (() => Promise<boolean>);\n\n/**\n * The options for the tour\n */\nexport interface TourOptions {\n  /**\n   * If true, will issue a `window.confirm` before cancelling.\n   * If it is a function(support Async Function), it will be called and wait for the return value,\n   * and will only be cancelled if the value returned is true.\n   */\n  confirmCancel?: TourConfirmCancel;\n  /**\n   * The message to display in the `window.confirm` dialog.\n   */\n  confirmCancelMessage?: string;\n  /**\n   * The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n   */\n  classPrefix?: string;\n  /**\n   * Default options for Steps ({@link Step#constructor}), created through `addStep`.\n   */\n  defaultStepOptions?: StepOptions;\n  /**\n   * Exiting the tour with the escape key will be enabled unless this is explicitly\n   * set to false.\n   */\n  exitOnEsc?: boolean;\n  /**\n   * Explicitly set the id for the tour. If not set, the id will be a generated uuid.\n   */\n  id?: string;\n  /**\n   * Navigating the tour via left and right arrow keys will be enabled\n   * unless this is explicitly set to false.\n   */\n  keyboardNavigation?: boolean;\n  /**\n   * An optional container element for the modal.\n   * If not set, the modal will be appended to `document.body`.\n   */\n  modalContainer?: HTMLElement;\n  /**\n   * An optional container element for the steps.\n   * If not set, the steps will be appended to `document.body`.\n   */\n  stepsContainer?: HTMLElement;\n  /**\n   * An array of step options objects or Step instances to initialize the tour with.\n   */\n  steps?: Array<StepOptions> | Array<Step>;\n  /**\n   * An optional \"name\" for the tour. This will be appended to the the tour's\n   * dynamically generated `id` property.\n   */\n  tourName?: string;\n  /**\n   * Whether or not steps should be placed above a darkened\n   * modal overlay. If true, the overlay will create an opening around the target element so that it\n   * can remain interactive\n   */\n  useModalOverlay?: boolean;\n}\n\nexport class ShepherdBase extends Evented {\n  activeTour?: Tour | null;\n  declare Step: typeof Step;\n  declare Tour: typeof Tour;\n\n  constructor() {\n    super();\n\n    autoBind(this);\n  }\n}\n\n/**\n * Class representing the site tour\n * @extends {Evented}\n */\nexport class Tour extends Evented {\n  trackedEvents = ['active', 'cancel', 'complete', 'show'];\n\n  classPrefix: string;\n  currentStep?: Step | null;\n  focusedElBeforeOpen?: HTMLElement | null;\n  id?: string;\n  modal?: ShepherdModalAPI | null;\n  options: TourOptions;\n  steps: Array<Step>;\n\n  constructor(options: TourOptions = {}) {\n    super();\n\n    autoBind(this);\n\n    const defaultTourOptions = {\n      exitOnEsc: true,\n      keyboardNavigation: true\n    };\n\n    this.options = Object.assign({}, defaultTourOptions, options);\n    this.classPrefix = normalizePrefix(this.options.classPrefix);\n    this.steps = [];\n    this.addSteps(this.options.steps);\n\n    // Pass these events onto the global Shepherd object\n    const events = [\n      'active',\n      'cancel',\n      'complete',\n      'inactive',\n      'show',\n      'start'\n    ];\n    events.map((event) => {\n      ((e) => {\n        this.on(e, (opts?: { [key: string]: unknown }) => {\n          opts = opts || {};\n          opts['tour'] = this;\n          Shepherd.trigger(e, opts);\n        });\n      })(event);\n    });\n\n    this._setTourID(options.id);\n\n    return this;\n  }\n\n  /**\n   * Adds a new step to the tour\n   * @param {StepOptions} options - An object containing step options or a Step instance\n   * @param {number | undefined} index - The optional index to insert the step at. If undefined, the step\n   * is added to the end of the array.\n   * @return The newly added step\n   */\n  addStep(options: StepOptions | Step, index?: number) {\n    let step = options;\n\n    if (!(step instanceof Step)) {\n      step = new Step(this, step);\n    } else {\n      step.tour = this;\n    }\n\n    if (!isUndefined(index)) {\n      this.steps.splice(index, 0, step as Step);\n    } else {\n      this.steps.push(step as Step);\n    }\n\n    return step;\n  }\n\n  /**\n   * Add multiple steps to the tour\n   * @param {Array<StepOptions> | Array<Step> | undefined} steps - The steps to add to the tour\n   */\n  addSteps(steps?: Array<StepOptions> | Array<Step>) {\n    if (Array.isArray(steps)) {\n      steps.forEach((step) => {\n        this.addStep(step);\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Go to the previous step in the tour\n   */\n  back() {\n    const index = this.steps.indexOf(this.currentStep as Step);\n    this.show(index - 1, false);\n  }\n\n  /**\n   * Calls _done() triggering the 'cancel' event\n   * If `confirmCancel` is true, will show a window.confirm before cancelling\n   * If `confirmCancel` is a function, will call it and wait for the return value,\n   * and only cancel when the value returned is true\n   */\n  async cancel() {\n    if (this.options.confirmCancel) {\n      const cancelMessage =\n        this.options.confirmCancelMessage ||\n        'Are you sure you want to stop the tour?';\n      let stopTour;\n\n      if (isFunction(this.options.confirmCancel)) {\n        stopTour = await this.options.confirmCancel();\n      } else {\n        stopTour = window.confirm(cancelMessage);\n      }\n\n      if (stopTour) {\n        this._done('cancel');\n      }\n    } else {\n      this._done('cancel');\n    }\n  }\n\n  /**\n   * Calls _done() triggering the `complete` event\n   */\n  complete() {\n    this._done('complete');\n  }\n\n  /**\n   * Gets the step from a given id\n   * @param {number | string} id - The id of the step to retrieve\n   * @return The step corresponding to the `id`\n   */\n  getById(id: number | string) {\n    return this.steps.find((step) => {\n      return step.id === id;\n    });\n  }\n\n  /**\n   * Gets the current step\n   */\n  getCurrentStep() {\n    return this.currentStep;\n  }\n\n  /**\n   * Hide the current step\n   */\n  hide() {\n    const currentStep = this.getCurrentStep();\n\n    if (currentStep) {\n      return currentStep.hide();\n    }\n  }\n\n  /**\n   * Check if the tour is active\n   */\n  isActive() {\n    return Shepherd.activeTour === this;\n  }\n\n  /**\n   * Go to the next step in the tour\n   * If we are at the end, call `complete`\n   */\n  next() {\n    const index = this.steps.indexOf(this.currentStep as Step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      this.show(index + 1, true);\n    }\n  }\n\n  /**\n   * Removes the step from the tour\n   * @param {string} name - The id for the step to remove\n   */\n  removeStep(name: string) {\n    const current = this.getCurrentStep();\n\n    // Find the step, destroy it and remove it from this.steps\n    this.steps.some((step, i) => {\n      if (step.id === name) {\n        if (step.isOpen()) {\n          step.hide();\n        }\n\n        step.destroy();\n        this.steps.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (current && current.id === name) {\n      this.currentStep = undefined;\n\n      // If we have steps left, show the first one, otherwise just cancel the tour\n      this.steps.length ? this.show(0) : this.cancel();\n    }\n  }\n\n  /**\n   * Show a specific step in the tour\n   * @param {number | string} key - The key to look up the step by\n   * @param {boolean} forward - True if we are going forward, false if backward\n   */\n  show(key: number | string = 0, forward = true) {\n    const step = isString(key) ? this.getById(key) : this.steps[key];\n\n    if (step) {\n      this._updateStateBeforeShow();\n\n      const shouldSkipStep =\n        isFunction(step.options.showOn) && !step.options.showOn();\n\n      // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n      if (shouldSkipStep) {\n        this._skipStep(step, forward);\n      } else {\n        this.currentStep = step;\n        this.trigger('show', {\n          step,\n          previous: this.currentStep\n        });\n\n        step.show();\n      }\n    }\n  }\n\n  /**\n   * Start the tour\n   */\n  async start() {\n    this.trigger('start');\n\n    // Save the focused element before the tour opens\n    this.focusedElBeforeOpen = document.activeElement as HTMLElement | null;\n\n    this.currentStep = null;\n\n    this.setupModal();\n\n    this._setupActiveTour();\n    this.next();\n  }\n\n  /**\n   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n   * @param {string} event - The event name to trigger\n   * @private\n   */\n  _done(event: string) {\n    const index = this.steps.indexOf(this.currentStep as Step);\n    if (Array.isArray(this.steps)) {\n      this.steps.forEach((step) => step.destroy());\n    }\n\n    cleanupSteps(this);\n\n    this.trigger(event, { index });\n\n    Shepherd.activeTour = null;\n    this.trigger('inactive', { tour: this });\n\n    if (this.modal) {\n      this.modal.hide();\n    }\n\n    if (event === 'cancel' || event === 'complete') {\n      if (this.modal) {\n        this.modal.destroy();\n        this.modal = null;\n      }\n    }\n\n    // Focus the element that was focused before the tour started\n    if (isHTMLElement(this.focusedElBeforeOpen)) {\n      this.focusedElBeforeOpen.focus();\n    }\n  }\n\n  /**\n   * Make this tour \"active\"\n   */\n  _setupActiveTour() {\n    this.trigger('active', { tour: this });\n\n    Shepherd.activeTour = this;\n  }\n\n  /**\n   * setupModal create the modal container and instance\n   */\n  setupModal() {\n    const container = this.options.modalContainer || document.body;\n    this.modal = createShepherdModal(container);\n  }\n\n  /**\n   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n   * @param {Step} step - The step to skip\n   * @param {boolean} forward - True if we are going forward, false if backward\n   * @private\n   */\n  _skipStep(step: Step, forward: boolean) {\n    const index = this.steps.indexOf(step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      const nextIndex = forward ? index + 1 : index - 1;\n      this.show(nextIndex, forward);\n    }\n  }\n\n  /**\n   * Before showing, hide the current step and if the tour is not\n   * already active, call `this._setupActiveTour`.\n   * @private\n   */\n  _updateStateBeforeShow() {\n    if (this.currentStep) {\n      this.currentStep.hide();\n    }\n\n    if (!this.isActive()) {\n      this._setupActiveTour();\n    }\n  }\n\n  /**\n   * Sets this.id to a provided tourName and id or `${tourName}--${uuid}`\n   * @param {string} optionsId - True if we are going forward, false if backward\n   * @private\n   */\n  _setTourID(optionsId: string | undefined) {\n    const tourName = this.options.tourName || 'tour';\n    const tourId = optionsId || uuid();\n\n    this.id = `${tourName}--${tourId}`;\n  }\n}\n\n/**\n * @public\n */\nconst Shepherd = new ShepherdBase();\n\nexport { Shepherd };\n", "import { Shepherd, Tour } from './tour.ts';\nimport { StepNoOp, TourNoOp } from './utils/general.ts';\nimport { Step } from './step.ts';\n\nconst isServerSide = typeof window === 'undefined';\n\nShepherd.Step = (isServerSide ? StepNoOp : Step) as unknown as typeof Step;\nShepherd.Tour = (isServerSide ? TourNoOp : Tour) as unknown as typeof Tour;\n\nexport { ShepherdBase } from './tour.ts';\nexport default Shepherd;\n// Reexport types so they can be more easily used.\nexport type * from './evented.ts';\nexport type * from './step.ts';\nexport type * from './tour.ts';\n", "import type { Tour } from '../tour.ts';\nimport { isHTMLElement } from './type-check.ts';\n\n/**\n * Cleanup the steps and set pointerEvents back to 'auto'\n * @param tour The tour object\n */\nexport function cleanupSteps(tour: Tour) {\n  if (tour) {\n    const { steps } = tour;\n\n    steps.forEach((step) => {\n      if (\n        step.options &&\n        step.options.canClickTarget === false &&\n        step.options.attachTo\n      ) {\n        if (isHTMLElement(step.target)) {\n          step.target.classList.remove('shepherd-target-click-disabled');\n        }\n\n        if (step._resolvedExtraHighlightElements) {\n          step._resolvedExtraHighlightElements.forEach((element) => {\n            if (isHTMLElement(element)) {\n              element.classList.remove('shepherd-target-click-disabled');\n            }\n          });\n        }\n      }\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["isHTMLElement", "value", "HTMLElement", "isFunction", "isString", "isUndefined", "Evented", "on", "event", "handler", "ctx", "once", "_this$bindings$event", "this", "bindings", "push", "off", "_this$bindings$event2", "forEach", "binding", "index", "_this$bindings$event3", "splice", "trigger", "args", "_this$bindings$event4", "context", "_this$bindings$event5", "apply", "t", "e", "n", "o", "actions", "defaultMerge", "Symbol", "skip", "defaultMetaDataUpdater", "previousMeta", "metaMeta", "defaultFilterValues", "values", "meta", "filter", "ObjectType", "getObjectType", "object", "Array", "isArray", "validRecordToStringValues", "includes", "Object", "prototype", "toString", "call", "constructor", "hasOwnProperty", "Set", "Map", "objectHasProperty", "property", "propertyIsEnumerable", "getIterableOfIterables", "iterables", "_iterables$", "mut_iterablesIndex", "mut_iterator", "iterator", "next", "done", "undefined", "result", "_iterables$mut_iterab", "mergeFunctions", "mergeRecords", "utils", "key", "objects", "keys", "getOwnPropertySymbols", "add", "propValues", "length", "updatedMeta", "metaDataUpdater", "parents", "propertyResult", "mergeUnknowns", "defineProperty", "configurable", "enumerable", "writable", "mergeArrays", "flat", "mergeSets", "mergeMaps", "mergeOthers", "at", "deepmerge", "options", "rootMetaData", "customizedDeepmerge", "_options$metaDataUpda", "_options$enableImplic", "_options$filterValues", "defaultMergeFunctions", "_extends", "fromEntries", "entries", "option", "hasOwn", "map", "useImplicitDefaultMerging", "enableImplicitDefaultMerging", "filterValues", "deepmergeCustom", "_utils$filterValues", "filteredValues", "type", "mut_index", "autoBind", "self", "getOwnPropertyNames", "i", "val", "bind", "bindAdvance", "step", "selector", "advanceOn", "isOpen", "targetIsEl", "el", "currentTarget", "matches", "tour", "document", "querySelector", "addEventListener", "removeEventListener", "body", "normalizePrefix", "prefix", "charAt", "shouldCenterStep", "resolvedAttachToOptions", "element", "uuid", "d", "Date", "now", "replace", "c", "r", "Math", "random", "floor", "alignments", "placements", "reduce", "acc", "side", "concat", "min", "max", "round", "createCoords", "v", "x", "y", "oppositeSideMap", "left", "right", "bottom", "top", "oppositeAlignmentMap", "start", "end", "clamp", "evaluate", "param", "getSide", "placement", "split", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "yAxisSides", "getSideAxis", "has", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "mainAlignmentSide", "reference", "floating", "getOppositePlacement", "getOppositeAlignmentPlacement", "lrPlacement", "rlPlacement", "tbPlacement", "btPlacement", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "isStart", "getPaddingObject", "padding", "rectToClientRect", "rect", "width", "height", "computeCoordsFromPlacement", "_ref", "sideAxis", "alignLength", "isVertical", "commonX", "commonY", "commonAlign", "coords", "async", "detectOverflow", "state", "_await$platform$isEle", "platform", "elements", "strategy", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "clippingClientRect", "getClippingRect", "isElement", "contextElement", "getDocumentElement", "offsetParent", "getOffsetParent", "offsetScale", "getScale", "elementClientRect", "convertOffsetParentRelativeRectToViewportRelativeRect", "originSides", "hasWindow", "window", "getNodeName", "node", "isNode", "nodeName", "toLowerCase", "getWindow", "_node$ownerDocument", "ownerDocument", "defaultView", "documentElement", "Node", "Element", "isShadowRoot", "ShadowRoot", "invalidOverflowDisplayValues", "isOverflowElement", "overflow", "overflowX", "overflowY", "display", "getComputedStyle", "test", "tableElements", "isTableElement", "topLayerSelectors", "isTopLayer", "some", "_e", "transformProperties", "willChangeValues", "containValues", "isContainingBlock", "elementOrCss", "webkit", "isWebKit", "css", "containerType", "backdropFilter", "willChange", "contain", "CSS", "supports", "lastTraversableNodeNames", "isLastTraversableNode", "getNodeScroll", "scrollLeft", "scrollTop", "scrollX", "scrollY", "getParentNode", "assignedSlot", "parentNode", "host", "getNearestOverflowAncestor", "getOverflowAncestors", "traverseIframes", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "frameElement", "getFrameElement", "visualViewport", "parent", "getPrototypeOf", "getCssDimensions", "getComputedStyle$1", "parseFloat", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "$", "unwrapElement", "domElement", "getBoundingClientRect", "Number", "isFinite", "noOffsets", "getVisualOffsets", "offsetLeft", "offsetTop", "includeScale", "isFixedStrategy", "clientRect", "scale", "visualOffsets", "isFixed", "floatingOffsetParent", "offsetWin", "currentWin", "currentIFrame", "iframeScale", "iframeRect", "clientLeft", "paddingLeft", "clientTop", "paddingTop", "getWindowScrollBarX", "leftScroll", "getHTMLOffset", "scroll", "htmlRect", "absoluteOrFixed", "getClientRectFromClippingAncestor", "clippingAncestor", "html", "clientWidth", "clientHeight", "visualViewportBased", "windowScrollbarX", "doc", "bodyStyles", "bodyMarginInline", "compatMode", "marginLeft", "marginRight", "clippingStableScrollbarWidth", "abs", "scrollWidth", "scrollHeight", "hasFixedPositionAncestor", "stopNode", "position", "getRectRelativeToOffsetParent", "isOffsetParentAnElement", "offsets", "setLeftRTLScrollbarOffset", "offsetRect", "htmlOffset", "isStaticPositioned", "getTrueOffsetParent", "polyfill", "rawOffsetParent", "svgOffsetParent", "currentNode", "topLayer", "clippingAncestors", "cache", "cachedResult", "get", "currentContainingBlockComputedStyle", "elementIsFixed", "computedStyle", "currentNodeIsContaining", "ancestor", "set", "_c", "firstClippingAncestor", "clippingRect", "accRect", "getElementRects", "data", "getOffsetParentFn", "getDimensionsFn", "getDimensions", "floatingDimensions", "getClientRects", "from", "isRTL", "rectsAreEqual", "a", "b", "autoUpdate", "update", "ancestorScroll", "ancestorResize", "elementResize", "ResizeObserver", "layoutShift", "IntersectionObserver", "animationFrame", "referenceEl", "ancestors", "passive", "cleanupIo", "onMove", "timeoutId", "io", "root", "cleanup", "_io", "clearTimeout", "disconnect", "refresh", "threshold", "elementRectForRootMargin", "rootMargin", "isFirstUpdate", "handleObserve", "ratio", "intersectionRatio", "setTimeout", "observe", "frameId", "reobserveFrame", "resizeObserver", "firstEntry", "target", "unobserve", "cancelAnimationFrame", "requestAnimationFrame", "_resizeObserver", "prevRefRect", "frameLoop", "nextRefRect", "_resizeObserver2", "autoPlacement", "name", "_middlewareData$autoP", "_middlewareData$autoP2", "_placementsThatFitOnE", "middlewareData", "_evaluate", "crossAxis", "allowedPlacements", "autoAlignment", "detectOverflowOptions", "_objectWithoutPropertiesLoose", "_excluded", "placements$1", "currentIndex", "currentPlacement", "alignmentSides", "reset", "currentOverflows", "allOverflows", "overflows", "nextPlacement", "placementsSortedByMostSpace", "slice", "sort", "resetPlacement", "every", "shift", "_evaluate4", "mainAxis", "checkMainAxis", "checkCrossAxis", "limiter", "fn", "_excluded4", "mainAxisCoord", "crossAxisCoord", "maxSide", "limitedCoords", "enabled", "flip", "_middlewareData$arrow", "_middlewareData$flip", "initialPlacement", "_evaluate2", "fallbackPlacements", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "_excluded2", "arrow", "alignmentOffset", "initialSideAxis", "isBasePlacement", "oppositePlacement", "hasFallbackAxisSideDirection", "overflowsData", "sides", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "_overflowsData$filter2", "currentSideAxis", "arrowDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "largestPossiblePadding", "minPadding", "maxPadding", "min$1", "center", "offset", "shouldAddOffset", "centerOffset", "limitShift", "rawOffset", "computedOffset", "len", "limitMin", "limitMax", "_middlewareData$offse", "_middlewareData$offse2", "isOriginSide", "computePosition", "mergedOptions", "platformWithCache", "config", "middleware", "validMiddleware", "Boolean", "statefulPlacement", "resetCount", "_platform$detectOverf", "nextX", "nextY", "setupTooltip", "attachToOptions", "_getResolvedAttachToOptions", "floatingUIOptions", "_attachToOptions$on", "_attachToOptions$on2", "_attachToOptions$on3", "arrowEl", "shouldCenter", "hasAutoPlacement", "hasEdgeAlignment", "_attachToOptions$on4", "pop", "arrowOptions", "_step$shepherdElement", "content", "shepherdElementComponent", "classList", "then", "assign", "style", "transform", "dataset", "arrowX", "arrowY", "Promise", "resolve", "tabIndex", "focus", "preventScroll", "h", "tag", "attrs", "children", "createElement", "applyAttrs", "appendChildren", "svgEl", "createElementNS", "startsWith", "disabled", "setAttribute", "String", "child", "append", "createTextNode", "getConfigOption", "createShepherdButton", "action", "label", "text", "btn", "class", "classes", "secondary", "onclick", "tabindex", "innerHTML", "createShepherdHeader", "labelId", "header", "title", "id", "resolvedTitle", "cancelIcon", "preventDefault", "cancel", "createShepherdContent", "descriptionId", "appendChild", "buttons", "footer", "Step", "super", "_resolvedAttachTo", "_resolvedExtraHighlightElements", "_originalTabIndexes", "classPrefix", "styles", "_setOptions", "complete", "destroy", "_teardownElements", "remove", "_updateStepTargetOnHide", "clear", "getTour", "hide", "_this$tour$modal", "modal", "hidden", "_resolveExtraHiglightElements", "extraHighlights", "flatMap", "highlight", "querySelectorAll", "_resolveAttachToOptions", "attachTo", "returnOpts", "show", "beforeShowPromise", "_show", "updateStepOptions", "_setupElements", "getElement", "getTarget", "_storeOriginalTabIndex", "originalValue", "getAttribute", "_restoreOriginalTabIndexes", "removeAttribute", "_createTooltipContent", "_step$options$cancelI", "_step$options", "_step$options$title", "_step$options2", "attachToElement", "focusableAttachToElements", "firstFocusableAttachToElement", "lastFocusableAttachToElement", "firstFocusableDialogElement", "focusableDialogElements", "lastFocusableDialogElement", "hasCancelIcon", "hasTitle", "handleKeyDown", "keyCode", "_document$activeEleme", "_ref2", "shiftKey", "activeElement", "contains", "_lastFocusableDialogE", "_firstFocusableDialog", "exitOnEsc", "stopPropagation", "keyboardNavigation", "back", "join", "onkeydown", "open", "focusableSelector", "_attachToElement", "stepsContainer", "_scrollTo", "scrollToOptions", "scrollToHandler", "scrollIntoView", "_getClassOptions", "stepOptions", "defaultStepOptions", "stepClasses", "defaultStepOptionsClasses", "allClasses", "uniqClasses", "trim", "tourOptions", "when", "_this$tour$modal2", "setupModal", "setupForStep", "_styleTargetElementForStep", "scrollTo", "extraHighlightElements", "targetElement", "highlightClass", "canClickTarget", "createShepherdModal", "container", "rafId", "openingProperties", "pathEl", "_updatePath", "overlayPaths", "openings", "innerWidth", "w", "innerHeight", "overlayPath", "topLeft", "topRight", "bottomRight", "bottomLeft", "closeModalOpening", "_cleanupStepEventListeners", "positionModal", "modalOverlayOpeningPadding", "modalOverlayOpeningRadius", "modalOverlayOpeningXOffset", "modalOverlayOpeningYOffset", "scrollParent", "elementsToHighlight", "newOpenings", "indexOf", "lastIndexOf", "_getVisibleHeight", "otherElement", "otherRect", "otherY", "otherHeight", "_preventModalOverlayTouch", "_preventModalBodyTouch", "_getScrollParent", "parentElement", "elementRect", "scrollRect", "scrollBottom", "useModalOverlay", "iframeOffset", "targetWindow", "_targetWindow", "targetIframe", "_unused", "rafLoop", "ShepherdBase", "activeTour", "Shepherd", "isServerSide", "_options", "Tour", "_tour", "trackedEvents", "currentStep", "focusedElBeforeOpen", "steps", "addSteps", "opts", "_setTourID", "addStep", "confirmCancel", "cancelMessage", "confirmCancelMessage", "stopTour", "confirm", "_done", "getById", "find", "getCurrentStep", "isActive", "removeStep", "current", "forward", "_updateStateBeforeShow", "showOn", "_skipStep", "previous", "_setupActiveTour", "modalContainer", "optionsId", "tourName", "tourId"]
}
