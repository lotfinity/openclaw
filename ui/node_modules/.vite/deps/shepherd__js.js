// ../node_modules/.pnpm/shepherd.js@15.0.0/node_modules/shepherd.js/dist/js/shepherd.mjs
function t(t2) {
  return t2 instanceof HTMLElement;
}
function e(t2) {
  return "function" == typeof t2;
}
function n(t2) {
  return "string" == typeof t2;
}
function o(t2) {
  return void 0 === t2;
}
var i = class {
  on(t2, e2, n2, i2 = false) {
    var s2;
    return o(this.bindings) && (this.bindings = {}), o(this.bindings[t2]) && (this.bindings[t2] = []), null == (s2 = this.bindings[t2]) || s2.push({ handler: e2, ctx: n2, once: i2 }), this;
  }
  once(t2, e2, n2) {
    return this.on(t2, e2, n2, true);
  }
  off(t2, e2) {
    if (o(this.bindings) || o(this.bindings[t2])) return this;
    var n2;
    o(e2) ? delete this.bindings[t2] : null == (n2 = this.bindings[t2]) || n2.forEach((n3, o2) => {
      var i2;
      n3.handler === e2 && (null == (i2 = this.bindings[t2]) || i2.splice(o2, 1));
    });
    return this;
  }
  trigger(t2, ...e2) {
    var n2;
    !o(this.bindings) && this.bindings[t2] && (null == (n2 = this.bindings[t2]) || n2.forEach((n3, o2) => {
      const { ctx: i2, handler: s2, once: r2 } = n3, l2 = i2 || this;
      var c2;
      (s2.apply(l2, e2), r2) && (null == (c2 = this.bindings[t2]) || c2.splice(o2, 1));
    }));
    return this;
  }
};
function s() {
  return s = Object.assign ? Object.assign.bind() : function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var n2 = arguments[e2];
      for (var o2 in n2) ({}).hasOwnProperty.call(n2, o2) && (t2[o2] = n2[o2]);
    }
    return t2;
  }, s.apply(null, arguments);
}
function r(t2, e2) {
  if (null == t2) return {};
  var n2 = {};
  for (var o2 in t2) if ({}.hasOwnProperty.call(t2, o2)) {
    if (-1 !== e2.indexOf(o2)) continue;
    n2[o2] = t2[o2];
  }
  return n2;
}
var l = { defaultMerge: /* @__PURE__ */ Symbol("deepmerge-ts: default merge"), skip: /* @__PURE__ */ Symbol("deepmerge-ts: skip") };
function c(t2, e2) {
  return e2;
}
function a(t2, e2) {
  return t2.filter((t3) => void 0 !== t3);
}
var u;
function h(t2) {
  return "object" != typeof t2 || null === t2 ? 0 : Array.isArray(t2) ? 2 : (function(t3) {
    if (!p.includes(Object.prototype.toString.call(t3))) return false;
    const { constructor: e2 } = t3;
    if (void 0 === e2) return true;
    const n2 = e2.prototype;
    if (null === n2 || "object" != typeof n2 || !p.includes(Object.prototype.toString.call(n2))) return false;
    if (!n2.hasOwnProperty("isPrototypeOf")) return false;
    return true;
  })(t2) ? 1 : t2 instanceof Set ? 3 : t2 instanceof Map ? 4 : 5;
}
function d(t2, e2) {
  return "object" == typeof t2 && Object.prototype.propertyIsEnumerable.call(t2, e2);
}
function f(t2) {
  var e2;
  let n2 = 0, o2 = null == (e2 = t2[0]) ? void 0 : e2[Symbol.iterator]();
  return { [Symbol.iterator]: () => ({ next() {
    for (; ; ) {
      if (void 0 === o2) return { done: true, value: void 0 };
      const i2 = o2.next();
      if (true !== i2.done) return { done: false, value: i2.value };
      var e3;
      n2 += 1, o2 = null == (e3 = t2[n2]) ? void 0 : e3[Symbol.iterator]();
    }
  } }) };
}
!(function(t2) {
  t2[t2.NOT = 0] = "NOT", t2[t2.RECORD = 1] = "RECORD", t2[t2.ARRAY = 2] = "ARRAY", t2[t2.SET = 3] = "SET", t2[t2.MAP = 4] = "MAP", t2[t2.OTHER = 5] = "OTHER";
})(u || (u = {}));
var p = ["[object Object]", "[object Module]"];
var g = { mergeRecords: function(t2, e2, n2) {
  const o2 = {};
  for (const i2 of (function(t3) {
    const e3 = /* @__PURE__ */ new Set();
    for (const n3 of t3) for (const t4 of [...Object.keys(n3), ...Object.getOwnPropertySymbols(n3)]) e3.add(t4);
    return e3;
  })(t2)) {
    const s2 = [];
    for (const e3 of t2) d(e3, i2) && s2.push(e3[i2]);
    if (0 === s2.length) continue;
    const r2 = e2.metaDataUpdater(n2, { key: i2, parents: t2 }), c2 = v(s2, e2, r2);
    c2 !== l.skip && ("__proto__" === i2 ? Object.defineProperty(o2, i2, { value: c2, configurable: true, enumerable: true, writable: true }) : o2[i2] = c2);
  }
  return o2;
}, mergeArrays: function(t2) {
  return t2.flat();
}, mergeSets: function(t2) {
  return new Set(f(t2));
}, mergeMaps: function(t2) {
  return new Map(f(t2));
}, mergeOthers: function(t2) {
  return t2.at(-1);
} };
function m(...t2) {
  return (function(t3, e2) {
    const n2 = (function(t4, e3) {
      var n3, o3, i2;
      return { defaultMergeFunctions: g, mergeFunctions: s({}, g, Object.fromEntries(Object.entries(t4).filter(([t5, e4]) => Object.hasOwn(g, t5)).map(([t5, e4]) => false === e4 ? [t5, g.mergeOthers] : [t5, e4]))), metaDataUpdater: null != (n3 = t4.metaDataUpdater) ? n3 : c, deepmerge: e3, useImplicitDefaultMerging: null != (o3 = t4.enableImplicitDefaultMerging) && o3, filterValues: false === t4.filterValues ? void 0 : null != (i2 = t4.filterValues) ? i2 : a, actions: l };
    })(t3, o2);
    function o2(...t4) {
      return v(t4, n2, e2);
    }
    return o2;
  })({})(...t2);
}
function v(t2, e2, n2) {
  var o2;
  const i2 = null != (o2 = null == e2.filterValues ? void 0 : e2.filterValues(t2, n2)) ? o2 : t2;
  if (0 === i2.length) return;
  if (1 === i2.length) return y(i2, e2, n2);
  const s2 = h(i2[0]);
  if (0 !== s2 && 5 !== s2) {
    for (let t3 = 1; t3 < i2.length; t3++) if (h(i2[t3]) !== s2) return y(i2, e2, n2);
  }
  switch (s2) {
    case 1:
      return (function(t3, e3, n3) {
        const o3 = e3.mergeFunctions.mergeRecords(t3, e3, n3);
        if (o3 === l.defaultMerge || e3.useImplicitDefaultMerging && void 0 === o3 && e3.mergeFunctions.mergeRecords !== e3.defaultMergeFunctions.mergeRecords) return e3.defaultMergeFunctions.mergeRecords(t3, e3, n3);
        return o3;
      })(i2, e2, n2);
    case 2:
      return (function(t3, e3, n3) {
        const o3 = e3.mergeFunctions.mergeArrays(t3, e3, n3);
        if (o3 === l.defaultMerge || e3.useImplicitDefaultMerging && void 0 === o3 && e3.mergeFunctions.mergeArrays !== e3.defaultMergeFunctions.mergeArrays) return e3.defaultMergeFunctions.mergeArrays(t3);
        return o3;
      })(i2, e2, n2);
    case 3:
      return (function(t3, e3, n3) {
        const o3 = e3.mergeFunctions.mergeSets(t3, e3, n3);
        if (o3 === l.defaultMerge || e3.useImplicitDefaultMerging && void 0 === o3 && e3.mergeFunctions.mergeSets !== e3.defaultMergeFunctions.mergeSets) return e3.defaultMergeFunctions.mergeSets(t3);
        return o3;
      })(i2, e2, n2);
    case 4:
      return (function(t3, e3, n3) {
        const o3 = e3.mergeFunctions.mergeMaps(t3, e3, n3);
        if (o3 === l.defaultMerge || e3.useImplicitDefaultMerging && void 0 === o3 && e3.mergeFunctions.mergeMaps !== e3.defaultMergeFunctions.mergeMaps) return e3.defaultMergeFunctions.mergeMaps(t3);
        return o3;
      })(i2, e2, n2);
    default:
      return y(i2, e2, n2);
  }
}
function y(t2, e2, n2) {
  const o2 = e2.mergeFunctions.mergeOthers(t2, e2, n2);
  return o2 === l.defaultMerge || e2.useImplicitDefaultMerging && void 0 === o2 && e2.mergeFunctions.mergeOthers !== e2.defaultMergeFunctions.mergeOthers ? e2.defaultMergeFunctions.mergeOthers(t2) : o2;
}
function x(t2) {
  const e2 = Object.getOwnPropertyNames(t2.constructor.prototype);
  for (let n2 = 0; n2 < e2.length; n2++) {
    const o2 = e2[n2], i2 = t2[o2];
    "constructor" !== o2 && "function" == typeof i2 && (t2[o2] = i2.bind(t2));
  }
  return t2;
}
function b(t2) {
  const { event: e2, selector: n2 } = t2.options.advanceOn || {};
  if (e2) {
    const i2 = /* @__PURE__ */ (function(t3, e3) {
      return (n3) => {
        if (t3.isOpen()) {
          const i3 = t3.el && n3.currentTarget === t3.el;
          (!o(e3) && n3.currentTarget.matches(e3) || i3) && t3.tour.next();
        }
      };
    })(t2, n2);
    let s2 = null;
    if (!o(n2) && (s2 = document.querySelector(n2), !s2)) return;
    s2 ? (s2.addEventListener(e2, i2), t2.on("destroy", () => s2.removeEventListener(e2, i2))) : (document.body.addEventListener(e2, i2, true), t2.on("destroy", () => document.body.removeEventListener(e2, i2, true)));
  }
}
function w(t2) {
  return n(t2) && "" !== t2 ? "-" !== t2.charAt(t2.length - 1) ? `${t2}-` : t2 : "";
}
function E(t2) {
  return null == t2 || (!t2.element || !t2.on);
}
function O() {
  let t2 = Date.now();
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e2) => {
    const n2 = (t2 + 16 * Math.random()) % 16 | 0;
    return t2 = Math.floor(t2 / 16), ("x" == e2 ? n2 : 3 & n2 | 8).toString(16);
  });
}
var T = ["start", "end"];
var S = ["top", "right", "bottom", "left"].reduce((t2, e2) => t2.concat(e2, e2 + "-" + T[0], e2 + "-" + T[1]), []);
var A = Math.min;
var L = Math.max;
var _ = Math.round;
var R = Math.floor;
var M = (t2) => ({ x: t2, y: t2 });
var P = { left: "right", right: "left", bottom: "top", top: "bottom" };
var C = { start: "end", end: "start" };
function k(t2, e2, n2) {
  return L(t2, A(e2, n2));
}
function D(t2, e2) {
  return "function" == typeof t2 ? t2(e2) : t2;
}
function $(t2) {
  return t2.split("-")[0];
}
function F(t2) {
  return t2.split("-")[1];
}
function I(t2) {
  return "x" === t2 ? "y" : "x";
}
function H(t2) {
  return "y" === t2 ? "height" : "width";
}
var j = /* @__PURE__ */ new Set(["top", "bottom"]);
function B(t2) {
  return j.has($(t2)) ? "y" : "x";
}
function V(t2) {
  return I(B(t2));
}
function N(t2, e2, n2) {
  void 0 === n2 && (n2 = false);
  const o2 = F(t2), i2 = V(t2), s2 = H(i2);
  let r2 = "x" === i2 ? o2 === (n2 ? "end" : "start") ? "right" : "left" : "start" === o2 ? "bottom" : "top";
  return e2.reference[s2] > e2.floating[s2] && (r2 = Z(r2)), [r2, Z(r2)];
}
function W(t2) {
  return t2.replace(/start|end/g, (t3) => C[t3]);
}
var q = ["left", "right"];
var U = ["right", "left"];
var z = ["top", "bottom"];
var Y = ["bottom", "top"];
function X(t2, e2, n2, o2) {
  const i2 = F(t2);
  let s2 = (function(t3, e3, n3) {
    switch (t3) {
      case "top":
      case "bottom":
        return n3 ? e3 ? U : q : e3 ? q : U;
      case "left":
      case "right":
        return e3 ? z : Y;
      default:
        return [];
    }
  })($(t2), "start" === n2, o2);
  return i2 && (s2 = s2.map((t3) => t3 + "-" + i2), e2 && (s2 = s2.concat(s2.map(W)))), s2;
}
function Z(t2) {
  return t2.replace(/left|right|bottom|top/g, (t3) => P[t3]);
}
function K(t2) {
  return "number" != typeof t2 ? (function(t3) {
    return s({ top: 0, right: 0, bottom: 0, left: 0 }, t3);
  })(t2) : { top: t2, right: t2, bottom: t2, left: t2 };
}
function G(t2) {
  const { x: e2, y: n2, width: o2, height: i2 } = t2;
  return { width: o2, height: i2, top: n2, left: e2, right: e2 + o2, bottom: n2 + i2, x: e2, y: n2 };
}
var J = ["crossAxis", "alignment", "allowedPlacements", "autoAlignment"];
var Q = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "flipAlignment"];
var tt = ["mainAxis", "crossAxis", "limiter"];
function et(t2, e2, n2) {
  let { reference: o2, floating: i2 } = t2;
  const s2 = B(e2), r2 = V(e2), l2 = H(r2), c2 = $(e2), a2 = "y" === s2, u2 = o2.x + o2.width / 2 - i2.width / 2, h2 = o2.y + o2.height / 2 - i2.height / 2, d2 = o2[l2] / 2 - i2[l2] / 2;
  let f2;
  switch (c2) {
    case "top":
      f2 = { x: u2, y: o2.y - i2.height };
      break;
    case "bottom":
      f2 = { x: u2, y: o2.y + o2.height };
      break;
    case "right":
      f2 = { x: o2.x + o2.width, y: h2 };
      break;
    case "left":
      f2 = { x: o2.x - i2.width, y: h2 };
      break;
    default:
      f2 = { x: o2.x, y: o2.y };
  }
  switch (F(e2)) {
    case "start":
      f2[r2] -= d2 * (n2 && a2 ? -1 : 1);
      break;
    case "end":
      f2[r2] += d2 * (n2 && a2 ? -1 : 1);
  }
  return f2;
}
async function nt(t2, e2) {
  var n2;
  void 0 === e2 && (e2 = {});
  const { x: o2, y: i2, platform: s2, rects: r2, elements: l2, strategy: c2 } = t2, { boundary: a2 = "clippingAncestors", rootBoundary: u2 = "viewport", elementContext: h2 = "floating", altBoundary: d2 = false, padding: f2 = 0 } = D(e2, t2), p2 = K(f2), g2 = l2[d2 ? "floating" === h2 ? "reference" : "floating" : h2], m2 = G(await s2.getClippingRect({ element: null == (n2 = await (null == s2.isElement ? void 0 : s2.isElement(g2))) || n2 ? g2 : g2.contextElement || await (null == s2.getDocumentElement ? void 0 : s2.getDocumentElement(l2.floating)), boundary: a2, rootBoundary: u2, strategy: c2 })), v2 = "floating" === h2 ? { x: o2, y: i2, width: r2.floating.width, height: r2.floating.height } : r2.reference, y2 = await (null == s2.getOffsetParent ? void 0 : s2.getOffsetParent(l2.floating)), x2 = await (null == s2.isElement ? void 0 : s2.isElement(y2)) && await (null == s2.getScale ? void 0 : s2.getScale(y2)) || { x: 1, y: 1 }, b2 = G(s2.convertOffsetParentRelativeRectToViewportRelativeRect ? await s2.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: l2, rect: v2, offsetParent: y2, strategy: c2 }) : v2);
  return { top: (m2.top - b2.top + p2.top) / x2.y, bottom: (b2.bottom - m2.bottom + p2.bottom) / x2.y, left: (m2.left - b2.left + p2.left) / x2.x, right: (b2.right - m2.right + p2.right) / x2.x };
}
var ot = /* @__PURE__ */ new Set(["left", "top"]);
function it() {
  return "undefined" != typeof window;
}
function st(t2) {
  return ct(t2) ? (t2.nodeName || "").toLowerCase() : "#document";
}
function rt(t2) {
  var e2;
  return (null == t2 || null == (e2 = t2.ownerDocument) ? void 0 : e2.defaultView) || window;
}
function lt(t2) {
  var e2;
  return null == (e2 = (ct(t2) ? t2.ownerDocument : t2.document) || window.document) ? void 0 : e2.documentElement;
}
function ct(t2) {
  return !!it() && (t2 instanceof Node || t2 instanceof rt(t2).Node);
}
function at(t2) {
  return !!it() && (t2 instanceof Element || t2 instanceof rt(t2).Element);
}
function ut(t2) {
  return !!it() && (t2 instanceof HTMLElement || t2 instanceof rt(t2).HTMLElement);
}
function ht(t2) {
  return !(!it() || "undefined" == typeof ShadowRoot) && (t2 instanceof ShadowRoot || t2 instanceof rt(t2).ShadowRoot);
}
var dt = /* @__PURE__ */ new Set(["inline", "contents"]);
function ft(t2) {
  const { overflow: e2, overflowX: n2, overflowY: o2, display: i2 } = St(t2);
  return /auto|scroll|overlay|hidden|clip/.test(e2 + o2 + n2) && !dt.has(i2);
}
var pt = /* @__PURE__ */ new Set(["table", "td", "th"]);
function gt(t2) {
  return pt.has(st(t2));
}
var mt = [":popover-open", ":modal"];
function vt(t2) {
  return mt.some((e2) => {
    try {
      return t2.matches(e2);
    } catch (t3) {
      return false;
    }
  });
}
var yt = ["transform", "translate", "scale", "rotate", "perspective"];
var xt = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var bt = ["paint", "layout", "strict", "content"];
function wt(t2) {
  const e2 = Et(), n2 = at(t2) ? St(t2) : t2;
  return yt.some((t3) => !!n2[t3] && "none" !== n2[t3]) || !!n2.containerType && "normal" !== n2.containerType || !e2 && !!n2.backdropFilter && "none" !== n2.backdropFilter || !e2 && !!n2.filter && "none" !== n2.filter || xt.some((t3) => (n2.willChange || "").includes(t3)) || bt.some((t3) => (n2.contain || "").includes(t3));
}
function Et() {
  return !("undefined" == typeof CSS || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
var Ot = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Tt(t2) {
  return Ot.has(st(t2));
}
function St(t2) {
  return rt(t2).getComputedStyle(t2);
}
function At(t2) {
  return at(t2) ? { scrollLeft: t2.scrollLeft, scrollTop: t2.scrollTop } : { scrollLeft: t2.scrollX, scrollTop: t2.scrollY };
}
function Lt(t2) {
  if ("html" === st(t2)) return t2;
  const e2 = t2.assignedSlot || t2.parentNode || ht(t2) && t2.host || lt(t2);
  return ht(e2) ? e2.host : e2;
}
function _t(t2) {
  const e2 = Lt(t2);
  return Tt(e2) ? t2.ownerDocument ? t2.ownerDocument.body : t2.body : ut(e2) && ft(e2) ? e2 : _t(e2);
}
function Rt(t2, e2, n2) {
  var o2;
  void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = true);
  const i2 = _t(t2), s2 = i2 === (null == (o2 = t2.ownerDocument) ? void 0 : o2.body), r2 = rt(i2);
  if (s2) {
    const t3 = Mt(r2);
    return e2.concat(r2, r2.visualViewport || [], ft(i2) ? i2 : [], t3 && n2 ? Rt(t3) : []);
  }
  return e2.concat(i2, Rt(i2, [], n2));
}
function Mt(t2) {
  return t2.parent && Object.getPrototypeOf(t2.parent) ? t2.frameElement : null;
}
function Pt(t2) {
  const e2 = St(t2);
  let n2 = parseFloat(e2.width) || 0, o2 = parseFloat(e2.height) || 0;
  const i2 = ut(t2), s2 = i2 ? t2.offsetWidth : n2, r2 = i2 ? t2.offsetHeight : o2, l2 = _(n2) !== s2 || _(o2) !== r2;
  return l2 && (n2 = s2, o2 = r2), { width: n2, height: o2, $: l2 };
}
function Ct(t2) {
  return at(t2) ? t2 : t2.contextElement;
}
function kt(t2) {
  const e2 = Ct(t2);
  if (!ut(e2)) return M(1);
  const n2 = e2.getBoundingClientRect(), { width: o2, height: i2, $: s2 } = Pt(e2);
  let r2 = (s2 ? _(n2.width) : n2.width) / o2, l2 = (s2 ? _(n2.height) : n2.height) / i2;
  return r2 && Number.isFinite(r2) || (r2 = 1), l2 && Number.isFinite(l2) || (l2 = 1), { x: r2, y: l2 };
}
var Dt = M(0);
function $t(t2) {
  const e2 = rt(t2);
  return Et() && e2.visualViewport ? { x: e2.visualViewport.offsetLeft, y: e2.visualViewport.offsetTop } : Dt;
}
function Ft(t2, e2, n2, o2) {
  void 0 === e2 && (e2 = false), void 0 === n2 && (n2 = false);
  const i2 = t2.getBoundingClientRect(), s2 = Ct(t2);
  let r2 = M(1);
  e2 && (o2 ? at(o2) && (r2 = kt(o2)) : r2 = kt(t2));
  const l2 = (function(t3, e3, n3) {
    return void 0 === e3 && (e3 = false), !(!n3 || e3 && n3 !== rt(t3)) && e3;
  })(s2, n2, o2) ? $t(s2) : M(0);
  let c2 = (i2.left + l2.x) / r2.x, a2 = (i2.top + l2.y) / r2.y, u2 = i2.width / r2.x, h2 = i2.height / r2.y;
  if (s2) {
    const t3 = rt(s2), e3 = o2 && at(o2) ? rt(o2) : o2;
    let n3 = t3, i3 = Mt(n3);
    for (; i3 && o2 && e3 !== n3; ) {
      const t4 = kt(i3), e4 = i3.getBoundingClientRect(), o3 = St(i3), s3 = e4.left + (i3.clientLeft + parseFloat(o3.paddingLeft)) * t4.x, r3 = e4.top + (i3.clientTop + parseFloat(o3.paddingTop)) * t4.y;
      c2 *= t4.x, a2 *= t4.y, u2 *= t4.x, h2 *= t4.y, c2 += s3, a2 += r3, n3 = rt(i3), i3 = Mt(n3);
    }
  }
  return G({ width: u2, height: h2, x: c2, y: a2 });
}
function It(t2, e2) {
  const n2 = At(t2).scrollLeft;
  return e2 ? e2.left + n2 : Ft(lt(t2)).left + n2;
}
function Ht(t2, e2) {
  const n2 = t2.getBoundingClientRect();
  return { x: n2.left + e2.scrollLeft - It(t2, n2), y: n2.top + e2.scrollTop };
}
var jt = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function Bt(t2, e2, n2) {
  let o2;
  if ("viewport" === e2) o2 = (function(t3, e3) {
    const n3 = rt(t3), o3 = lt(t3), i2 = n3.visualViewport;
    let s2 = o3.clientWidth, r2 = o3.clientHeight, l2 = 0, c2 = 0;
    if (i2) {
      s2 = i2.width, r2 = i2.height;
      const t4 = Et();
      (!t4 || t4 && "fixed" === e3) && (l2 = i2.offsetLeft, c2 = i2.offsetTop);
    }
    const a2 = It(o3);
    if (a2 <= 0) {
      const t4 = o3.ownerDocument, e4 = t4.body, n4 = getComputedStyle(e4), i3 = "CSS1Compat" === t4.compatMode && parseFloat(n4.marginLeft) + parseFloat(n4.marginRight) || 0, r3 = Math.abs(o3.clientWidth - e4.clientWidth - i3);
      r3 <= 25 && (s2 -= r3);
    } else a2 <= 25 && (s2 += a2);
    return { width: s2, height: r2, x: l2, y: c2 };
  })(t2, n2);
  else if ("document" === e2) o2 = (function(t3) {
    const e3 = lt(t3), n3 = At(t3), o3 = t3.ownerDocument.body, i2 = L(e3.scrollWidth, e3.clientWidth, o3.scrollWidth, o3.clientWidth), s2 = L(e3.scrollHeight, e3.clientHeight, o3.scrollHeight, o3.clientHeight);
    let r2 = -n3.scrollLeft + It(t3);
    const l2 = -n3.scrollTop;
    return "rtl" === St(o3).direction && (r2 += L(e3.clientWidth, o3.clientWidth) - i2), { width: i2, height: s2, x: r2, y: l2 };
  })(lt(t2));
  else if (at(e2)) o2 = (function(t3, e3) {
    const n3 = Ft(t3, true, "fixed" === e3), o3 = n3.top + t3.clientTop, i2 = n3.left + t3.clientLeft, s2 = ut(t3) ? kt(t3) : M(1);
    return { width: t3.clientWidth * s2.x, height: t3.clientHeight * s2.y, x: i2 * s2.x, y: o3 * s2.y };
  })(e2, n2);
  else {
    const n3 = $t(t2);
    o2 = { x: e2.x - n3.x, y: e2.y - n3.y, width: e2.width, height: e2.height };
  }
  return G(o2);
}
function Vt(t2, e2) {
  const n2 = Lt(t2);
  return !(n2 === e2 || !at(n2) || Tt(n2)) && ("fixed" === St(n2).position || Vt(n2, e2));
}
function Nt(t2, e2, n2) {
  const o2 = ut(e2), i2 = lt(e2), s2 = "fixed" === n2, r2 = Ft(t2, true, s2, e2);
  let l2 = { scrollLeft: 0, scrollTop: 0 };
  const c2 = M(0);
  function a2() {
    c2.x = It(i2);
  }
  if (o2 || !o2 && !s2) if (("body" !== st(e2) || ft(i2)) && (l2 = At(e2)), o2) {
    const t3 = Ft(e2, true, s2, e2);
    c2.x = t3.x + e2.clientLeft, c2.y = t3.y + e2.clientTop;
  } else i2 && a2();
  s2 && !o2 && i2 && a2();
  const u2 = !i2 || o2 || s2 ? M(0) : Ht(i2, l2);
  return { x: r2.left + l2.scrollLeft - c2.x - u2.x, y: r2.top + l2.scrollTop - c2.y - u2.y, width: r2.width, height: r2.height };
}
function Wt(t2) {
  return "static" === St(t2).position;
}
function qt(t2, e2) {
  if (!ut(t2) || "fixed" === St(t2).position) return null;
  if (e2) return e2(t2);
  let n2 = t2.offsetParent;
  return lt(t2) === n2 && (n2 = n2.ownerDocument.body), n2;
}
function Ut(t2, e2) {
  const n2 = rt(t2);
  if (vt(t2)) return n2;
  if (!ut(t2)) {
    let e3 = Lt(t2);
    for (; e3 && !Tt(e3); ) {
      if (at(e3) && !Wt(e3)) return e3;
      e3 = Lt(e3);
    }
    return n2;
  }
  let o2 = qt(t2, e2);
  for (; o2 && gt(o2) && Wt(o2); ) o2 = qt(o2, e2);
  return o2 && Tt(o2) && Wt(o2) && !wt(o2) ? n2 : o2 || (function(t3) {
    let e3 = Lt(t3);
    for (; ut(e3) && !Tt(e3); ) {
      if (wt(e3)) return e3;
      if (vt(e3)) return null;
      e3 = Lt(e3);
    }
    return null;
  })(t2) || n2;
}
var zt = { convertOffsetParentRelativeRectToViewportRelativeRect: function(t2) {
  let { elements: e2, rect: n2, offsetParent: o2, strategy: i2 } = t2;
  const s2 = "fixed" === i2, r2 = lt(o2), l2 = !!e2 && vt(e2.floating);
  if (o2 === r2 || l2 && s2) return n2;
  let c2 = { scrollLeft: 0, scrollTop: 0 }, a2 = M(1);
  const u2 = M(0), h2 = ut(o2);
  if ((h2 || !h2 && !s2) && (("body" !== st(o2) || ft(r2)) && (c2 = At(o2)), ut(o2))) {
    const t3 = Ft(o2);
    a2 = kt(o2), u2.x = t3.x + o2.clientLeft, u2.y = t3.y + o2.clientTop;
  }
  const d2 = !r2 || h2 || s2 ? M(0) : Ht(r2, c2);
  return { width: n2.width * a2.x, height: n2.height * a2.y, x: n2.x * a2.x - c2.scrollLeft * a2.x + u2.x + d2.x, y: n2.y * a2.y - c2.scrollTop * a2.y + u2.y + d2.y };
}, getDocumentElement: lt, getClippingRect: function(t2) {
  let { element: e2, boundary: n2, rootBoundary: o2, strategy: i2 } = t2;
  const s2 = [..."clippingAncestors" === n2 ? vt(e2) ? [] : (function(t3, e3) {
    const n3 = e3.get(t3);
    if (n3) return n3;
    let o3 = Rt(t3, [], false).filter((t4) => at(t4) && "body" !== st(t4)), i3 = null;
    const s3 = "fixed" === St(t3).position;
    let r3 = s3 ? Lt(t3) : t3;
    for (; at(r3) && !Tt(r3); ) {
      const e4 = St(r3), n4 = wt(r3);
      n4 || "fixed" !== e4.position || (i3 = null), (s3 ? !n4 && !i3 : !n4 && "static" === e4.position && i3 && jt.has(i3.position) || ft(r3) && !n4 && Vt(t3, r3)) ? o3 = o3.filter((t4) => t4 !== r3) : i3 = e4, r3 = Lt(r3);
    }
    return e3.set(t3, o3), o3;
  })(e2, this._c) : [].concat(n2), o2], r2 = s2[0], l2 = s2.reduce((t3, n3) => {
    const o3 = Bt(e2, n3, i2);
    return t3.top = L(o3.top, t3.top), t3.right = A(o3.right, t3.right), t3.bottom = A(o3.bottom, t3.bottom), t3.left = L(o3.left, t3.left), t3;
  }, Bt(e2, r2, i2));
  return { width: l2.right - l2.left, height: l2.bottom - l2.top, x: l2.left, y: l2.top };
}, getOffsetParent: Ut, getElementRects: async function(t2) {
  const e2 = this.getOffsetParent || Ut, n2 = this.getDimensions, o2 = await n2(t2.floating);
  return { reference: Nt(t2.reference, await e2(t2.floating), t2.strategy), floating: { x: 0, y: 0, width: o2.width, height: o2.height } };
}, getClientRects: function(t2) {
  return Array.from(t2.getClientRects());
}, getDimensions: function(t2) {
  const { width: e2, height: n2 } = Pt(t2);
  return { width: e2, height: n2 };
}, getScale: kt, isElement: at, isRTL: function(t2) {
  return "rtl" === St(t2).direction;
} };
function Yt(t2, e2) {
  return t2.x === e2.x && t2.y === e2.y && t2.width === e2.width && t2.height === e2.height;
}
function Xt(t2, e2, n2, o2) {
  void 0 === o2 && (o2 = {});
  const { ancestorScroll: i2 = true, ancestorResize: r2 = true, elementResize: l2 = "function" == typeof ResizeObserver, layoutShift: c2 = "function" == typeof IntersectionObserver, animationFrame: a2 = false } = o2, u2 = Ct(t2), h2 = i2 || r2 ? [...u2 ? Rt(u2) : [], ...Rt(e2)] : [];
  h2.forEach((t3) => {
    i2 && t3.addEventListener("scroll", n2, { passive: true }), r2 && t3.addEventListener("resize", n2);
  });
  const d2 = u2 && c2 ? (function(t3, e3) {
    let n3, o3 = null;
    const i3 = lt(t3);
    function r3() {
      var t4;
      clearTimeout(n3), null == (t4 = o3) || t4.disconnect(), o3 = null;
    }
    return (function l3(c3, a3) {
      void 0 === c3 && (c3 = false), void 0 === a3 && (a3 = 1), r3();
      const u3 = t3.getBoundingClientRect(), { left: h3, top: d3, width: f3, height: p3 } = u3;
      if (c3 || e3(), !f3 || !p3) return;
      const g3 = { rootMargin: -R(d3) + "px " + -R(i3.clientWidth - (h3 + f3)) + "px " + -R(i3.clientHeight - (d3 + p3)) + "px " + -R(h3) + "px", threshold: L(0, A(1, a3)) || 1 };
      let m3 = true;
      function v2(e4) {
        const o4 = e4[0].intersectionRatio;
        if (o4 !== a3) {
          if (!m3) return l3();
          o4 ? l3(false, o4) : n3 = setTimeout(() => {
            l3(false, 1e-7);
          }, 1e3);
        }
        1 !== o4 || Yt(u3, t3.getBoundingClientRect()) || l3(), m3 = false;
      }
      try {
        o3 = new IntersectionObserver(v2, s({}, g3, { root: i3.ownerDocument }));
      } catch (t4) {
        o3 = new IntersectionObserver(v2, g3);
      }
      o3.observe(t3);
    })(true), r3;
  })(u2, n2) : null;
  let f2, p2 = -1, g2 = null;
  l2 && (g2 = new ResizeObserver((t3) => {
    let [o3] = t3;
    o3 && o3.target === u2 && g2 && (g2.unobserve(e2), cancelAnimationFrame(p2), p2 = requestAnimationFrame(() => {
      var t4;
      null == (t4 = g2) || t4.observe(e2);
    })), n2();
  }), u2 && !a2 && g2.observe(u2), g2.observe(e2));
  let m2 = a2 ? Ft(t2) : null;
  return a2 && (function e3() {
    const o3 = Ft(t2);
    m2 && !Yt(m2, o3) && n2();
    m2 = o3, f2 = requestAnimationFrame(e3);
  })(), n2(), () => {
    var t3;
    h2.forEach((t4) => {
      i2 && t4.removeEventListener("scroll", n2), r2 && t4.removeEventListener("resize", n2);
    }), null == d2 || d2(), null == (t3 = g2) || t3.disconnect(), g2 = null, a2 && cancelAnimationFrame(f2);
  };
}
var Zt = function(t2) {
  return void 0 === t2 && (t2 = {}), { name: "autoPlacement", options: t2, async fn(e2) {
    var n2, o2, i2;
    const { rects: s2, middlewareData: l2, placement: c2, platform: a2, elements: u2 } = e2, h2 = D(t2, e2), { crossAxis: d2 = false, alignment: f2, allowedPlacements: p2 = S, autoAlignment: g2 = true } = h2, m2 = r(h2, J), v2 = void 0 !== f2 || p2 === S ? (function(t3, e3, n3) {
      return (t3 ? [...n3.filter((e4) => F(e4) === t3), ...n3.filter((e4) => F(e4) !== t3)] : n3.filter((t4) => $(t4) === t4)).filter((n4) => !t3 || F(n4) === t3 || !!e3 && W(n4) !== n4);
    })(f2 || null, g2, p2) : p2, y2 = await a2.detectOverflow(e2, m2), x2 = (null == (n2 = l2.autoPlacement) ? void 0 : n2.index) || 0, b2 = v2[x2];
    if (null == b2) return {};
    const w2 = N(b2, s2, await (null == a2.isRTL ? void 0 : a2.isRTL(u2.floating)));
    if (c2 !== b2) return { reset: { placement: v2[0] } };
    const E2 = [y2[$(b2)], y2[w2[0]], y2[w2[1]]], O2 = [...(null == (o2 = l2.autoPlacement) ? void 0 : o2.overflows) || [], { placement: b2, overflows: E2 }], T2 = v2[x2 + 1];
    if (T2) return { data: { index: x2 + 1, overflows: O2 }, reset: { placement: T2 } };
    const A2 = O2.map((t3) => {
      const e3 = F(t3.placement);
      return [t3.placement, e3 && d2 ? t3.overflows.slice(0, 2).reduce((t4, e4) => t4 + e4, 0) : t3.overflows[0], t3.overflows];
    }).sort((t3, e3) => t3[1] - e3[1]), L2 = (null == (i2 = A2.filter((t3) => t3[2].slice(0, F(t3[0]) ? 2 : 3).every((t4) => t4 <= 0))[0]) ? void 0 : i2[0]) || A2[0][0];
    return L2 !== c2 ? { data: { index: x2 + 1, overflows: O2 }, reset: { placement: L2 } } : {};
  } };
};
var Kt = function(t2) {
  return void 0 === t2 && (t2 = {}), { name: "shift", options: t2, async fn(e2) {
    const { x: n2, y: o2, placement: i2, platform: l2 } = e2, c2 = D(t2, e2), { mainAxis: a2 = true, crossAxis: u2 = false, limiter: h2 = { fn: (t3) => {
      let { x: e3, y: n3 } = t3;
      return { x: e3, y: n3 };
    } } } = c2, d2 = r(c2, tt), f2 = { x: n2, y: o2 }, p2 = await l2.detectOverflow(e2, d2), g2 = B($(i2)), m2 = I(g2);
    let v2 = f2[m2], y2 = f2[g2];
    if (a2) {
      const t3 = "y" === m2 ? "bottom" : "right";
      v2 = k(v2 + p2["y" === m2 ? "top" : "left"], v2, v2 - p2[t3]);
    }
    if (u2) {
      const t3 = "y" === g2 ? "bottom" : "right";
      y2 = k(y2 + p2["y" === g2 ? "top" : "left"], y2, y2 - p2[t3]);
    }
    const x2 = h2.fn(s({}, e2, { [m2]: v2, [g2]: y2 }));
    return s({}, x2, { data: { x: x2.x - n2, y: x2.y - o2, enabled: { [m2]: a2, [g2]: u2 } } });
  } };
};
var Gt = function(t2) {
  return void 0 === t2 && (t2 = {}), { name: "flip", options: t2, async fn(e2) {
    var n2, o2;
    const { placement: i2, middlewareData: s2, rects: l2, initialPlacement: c2, platform: a2, elements: u2 } = e2, h2 = D(t2, e2), { mainAxis: d2 = true, crossAxis: f2 = true, fallbackPlacements: p2, fallbackStrategy: g2 = "bestFit", fallbackAxisSideDirection: m2 = "none", flipAlignment: v2 = true } = h2, y2 = r(h2, Q);
    if (null != (n2 = s2.arrow) && n2.alignmentOffset) return {};
    const x2 = $(i2), b2 = B(c2), w2 = $(c2) === c2, E2 = await (null == a2.isRTL ? void 0 : a2.isRTL(u2.floating)), O2 = p2 || (w2 || !v2 ? [Z(c2)] : (function(t3) {
      const e3 = Z(t3);
      return [W(t3), e3, W(e3)];
    })(c2)), T2 = "none" !== m2;
    !p2 && T2 && O2.push(...X(c2, v2, m2, E2));
    const S2 = [c2, ...O2], A2 = await a2.detectOverflow(e2, y2), L2 = [];
    let _2 = (null == (o2 = s2.flip) ? void 0 : o2.overflows) || [];
    if (d2 && L2.push(A2[x2]), f2) {
      const t3 = N(i2, l2, E2);
      L2.push(A2[t3[0]], A2[t3[1]]);
    }
    if (_2 = [..._2, { placement: i2, overflows: L2 }], !L2.every((t3) => t3 <= 0)) {
      var R2, M2;
      const t3 = ((null == (R2 = s2.flip) ? void 0 : R2.index) || 0) + 1, e3 = S2[t3];
      if (e3) {
        if (!("alignment" === f2 && b2 !== B(e3)) || _2.every((t4) => B(t4.placement) !== b2 || t4.overflows[0] > 0)) return { data: { index: t3, overflows: _2 }, reset: { placement: e3 } };
      }
      let n3 = null == (M2 = _2.filter((t4) => t4.overflows[0] <= 0).sort((t4, e4) => t4.overflows[1] - e4.overflows[1])[0]) ? void 0 : M2.placement;
      if (!n3) switch (g2) {
        case "bestFit": {
          var P2;
          const t4 = null == (P2 = _2.filter((t5) => {
            if (T2) {
              const e4 = B(t5.placement);
              return e4 === b2 || "y" === e4;
            }
            return true;
          }).map((t5) => [t5.placement, t5.overflows.filter((t6) => t6 > 0).reduce((t6, e4) => t6 + e4, 0)]).sort((t5, e4) => t5[1] - e4[1])[0]) ? void 0 : P2[0];
          t4 && (n3 = t4);
          break;
        }
        case "initialPlacement":
          n3 = c2;
      }
      if (i2 !== n3) return { reset: { placement: n3 } };
    }
    return {};
  } };
};
var Jt = (t2) => ({ name: "arrow", options: t2, async fn(e2) {
  const { x: n2, y: o2, placement: i2, rects: r2, platform: l2, elements: c2, middlewareData: a2 } = e2, { element: u2, padding: h2 = 0 } = D(t2, e2) || {};
  if (null == u2) return {};
  const d2 = K(h2), f2 = { x: n2, y: o2 }, p2 = V(i2), g2 = H(p2), m2 = await l2.getDimensions(u2), v2 = "y" === p2, y2 = v2 ? "top" : "left", x2 = v2 ? "bottom" : "right", b2 = v2 ? "clientHeight" : "clientWidth", w2 = r2.reference[g2] + r2.reference[p2] - f2[p2] - r2.floating[g2], E2 = f2[p2] - r2.reference[p2], O2 = await (null == l2.getOffsetParent ? void 0 : l2.getOffsetParent(u2));
  let T2 = O2 ? O2[b2] : 0;
  T2 && await (null == l2.isElement ? void 0 : l2.isElement(O2)) || (T2 = c2.floating[b2] || r2.floating[g2]);
  const S2 = w2 / 2 - E2 / 2, L2 = T2 / 2 - m2[g2] / 2 - 1, _2 = A(d2[y2], L2), R2 = A(d2[x2], L2), M2 = _2, P2 = T2 - m2[g2] - R2, C2 = T2 / 2 - m2[g2] / 2 + S2, $2 = k(M2, C2, P2), I2 = !a2.arrow && null != F(i2) && C2 !== $2 && r2.reference[g2] / 2 - (C2 < M2 ? _2 : R2) - m2[g2] / 2 < 0, j2 = I2 ? C2 < M2 ? C2 - M2 : C2 - P2 : 0;
  return { [p2]: f2[p2] + j2, data: s({ [p2]: $2, centerOffset: C2 - $2 - j2 }, I2 && { alignmentOffset: j2 }), reset: I2 };
} });
var Qt = function(t2) {
  return void 0 === t2 && (t2 = {}), { options: t2, fn(e2) {
    const { x: n2, y: o2, placement: i2, rects: r2, middlewareData: l2 } = e2, { offset: c2 = 0, mainAxis: a2 = true, crossAxis: u2 = true } = D(t2, e2), h2 = { x: n2, y: o2 }, d2 = B(i2), f2 = I(d2);
    let p2 = h2[f2], g2 = h2[d2];
    const m2 = D(c2, e2), v2 = "number" == typeof m2 ? { mainAxis: m2, crossAxis: 0 } : s({ mainAxis: 0, crossAxis: 0 }, m2);
    if (a2) {
      const t3 = "y" === f2 ? "height" : "width", e3 = r2.reference[f2] - r2.floating[t3] + v2.mainAxis, n3 = r2.reference[f2] + r2.reference[t3] - v2.mainAxis;
      p2 < e3 ? p2 = e3 : p2 > n3 && (p2 = n3);
    }
    if (u2) {
      var y2, x2;
      const t3 = "y" === f2 ? "width" : "height", e3 = ot.has($(i2)), n3 = r2.reference[d2] - r2.floating[t3] + (e3 && (null == (y2 = l2.offset) ? void 0 : y2[d2]) || 0) + (e3 ? 0 : v2.crossAxis), o3 = r2.reference[d2] + r2.reference[t3] + (e3 ? 0 : (null == (x2 = l2.offset) ? void 0 : x2[d2]) || 0) - (e3 ? v2.crossAxis : 0);
      g2 < n3 ? g2 = n3 : g2 > o3 && (g2 = o3);
    }
    return { [f2]: p2, [d2]: g2 };
  } };
};
var te = (t2, e2, n2) => {
  const o2 = /* @__PURE__ */ new Map(), i2 = s({ platform: zt }, n2), r2 = s({}, i2.platform, { _c: o2 });
  return (async (t3, e3, n3) => {
    const { placement: o3 = "bottom", strategy: i3 = "absolute", middleware: r3 = [], platform: l2 } = n3, c2 = r3.filter(Boolean), a2 = await (null == l2.isRTL ? void 0 : l2.isRTL(e3));
    let u2 = await l2.getElementRects({ reference: t3, floating: e3, strategy: i3 }), { x: h2, y: d2 } = et(u2, o3, a2), f2 = o3, p2 = {}, g2 = 0;
    for (let n4 = 0; n4 < c2.length; n4++) {
      var m2;
      const { name: r4, fn: v2 } = c2[n4], { x: y2, y: x2, data: b2, reset: w2 } = await v2({ x: h2, y: d2, initialPlacement: o3, placement: f2, strategy: i3, middlewareData: p2, rects: u2, platform: s({}, l2, { detectOverflow: null != (m2 = l2.detectOverflow) ? m2 : nt }), elements: { reference: t3, floating: e3 } });
      h2 = null != y2 ? y2 : h2, d2 = null != x2 ? x2 : d2, p2 = s({}, p2, { [r4]: s({}, p2[r4], b2) }), w2 && g2 <= 50 && (g2++, "object" == typeof w2 && (w2.placement && (f2 = w2.placement), w2.rects && (u2 = true === w2.rects ? await l2.getElementRects({ reference: t3, floating: e3, strategy: i3 }) : w2.rects), { x: h2, y: d2 } = et(u2, f2, a2)), n4 = -1);
    }
    return { x: h2, y: d2, placement: f2, strategy: i3, middlewareData: p2 };
  })(t2, e2, s({}, i2, { platform: r2 }));
};
function ee(e2) {
  e2.cleanup && e2.cleanup();
  const n2 = e2._getResolvedAttachToOptions();
  let o2 = n2.element;
  const i2 = (function(t2, e3) {
    var n3, o3, i3;
    const s3 = { strategy: "absolute", middleware: [] }, r3 = (function(t3) {
      if (t3.options.arrow && t3.el) return t3.el.querySelector(".shepherd-arrow");
      return false;
    })(e3), l2 = E(t2), c2 = null == (n3 = t2.on) ? void 0 : n3.includes("auto"), a2 = (null == t2 || null == (o3 = t2.on) ? void 0 : o3.includes("-start")) || (null == t2 || null == (i3 = t2.on) ? void 0 : i3.includes("-end"));
    if (!l2) {
      var u2;
      if (c2) s3.middleware.push(Zt({ crossAxis: true, alignment: a2 ? null == t2 || null == (u2 = t2.on) ? void 0 : u2.split("-").pop() : null }));
      else s3.middleware.push(Gt());
      if (s3.middleware.push(Kt({ limiter: Qt(), crossAxis: true })), r3) {
        const t3 = "object" == typeof e3.options.arrow ? e3.options.arrow : { padding: 4 };
        s3.middleware.push(Jt({ element: r3, padding: a2 ? t3.padding : 0 }));
      }
      c2 || (s3.placement = t2.on);
    }
    return m(s3, e3.options.floatingUIOptions || {});
  })(n2, e2), s2 = E(n2);
  if (s2) {
    var r2;
    o2 = document.body;
    const t2 = null == (r2 = e2.shepherdElementComponent) ? void 0 : r2.element;
    null == t2 || t2.classList.add("shepherd-centered");
  }
  return e2.cleanup = Xt(o2, e2.el, () => {
    e2.el ? (function(e3, n3, o3, i3) {
      te(e3, n3.el, o3).then(/* @__PURE__ */ (function(e4, n4) {
        return ({ x: o4, y: i4, placement: s3, middlewareData: r3 }) => e4.el ? (n4 ? Object.assign(e4.el.style, { position: "fixed", left: "50%", top: "50%", transform: "translate(-50%, -50%)" }) : Object.assign(e4.el.style, { position: "absolute", left: `${o4}px`, top: `${i4}px` }), e4.el.dataset.popperPlacement = s3, (function(e5, n5) {
          const o5 = e5.querySelector(".shepherd-arrow");
          if (t(o5) && n5.arrow) {
            const { x: t2, y: e6 } = n5.arrow;
            Object.assign(o5.style, { left: null != t2 ? `${t2}px` : "", top: null != e6 ? `${e6}px` : "" });
          }
        })(e4.el, r3), e4) : e4;
      })(n3, i3)).then((t2) => new Promise((e4) => {
        setTimeout(() => e4(t2), 300);
      })).then((t2) => {
        null != t2 && t2.el && (t2.el.tabIndex = 0, t2.el.focus({ preventScroll: true }));
      });
    })(o2, e2, i2, s2) : null == e2.cleanup || e2.cleanup();
  }), e2.target = n2.element, i2;
}
function ne(t2, e2, ...n2) {
  const o2 = document.createElement(t2);
  return ie(o2, e2), se(o2, n2), o2;
}
function oe(t2, e2, ...n2) {
  const o2 = document.createElementNS("http://www.w3.org/2000/svg", t2);
  return ie(o2, e2), se(o2, n2), o2;
}
function ie(t2, e2) {
  if (e2) for (const [n2, o2] of Object.entries(e2)) null != o2 && false !== o2 && (n2.startsWith("on") && "function" == typeof o2 ? t2.addEventListener(n2.slice(2).toLowerCase(), o2) : "disabled" === n2 && true === o2 ? t2.disabled = true : t2.setAttribute(n2, String(o2)));
}
function se(t2, e2) {
  for (const n2 of e2) null != n2 && false !== n2 && t2.append("string" == typeof n2 ? document.createTextNode(n2) : n2);
}
function re(t2, n2) {
  return e(t2) ? t2.call(n2) : t2;
}
function le(t2, e2) {
  const n2 = t2.action ? t2.action.bind(e2.tour) : null, o2 = !!t2.disabled && re(t2.disabled, e2), i2 = t2.label ? re(t2.label, e2) : null, s2 = t2.text ? re(t2.text, e2) : null, r2 = ne("button", { "aria-label": i2 || null, class: `${t2.classes || ""} shepherd-button ${t2.secondary ? "shepherd-button-secondary" : ""}`, disabled: o2 || null, onclick: n2, tabindex: "0", type: "button" });
  return s2 && (r2.innerHTML = s2), r2;
}
function ce(t2, n2) {
  const o2 = ne("header", { class: "shepherd-header" });
  return n2.options.title && o2.append((function(t3, n3) {
    const o3 = ne("h3", { id: t3, class: "shepherd-title" }), i2 = e(n3) ? n3() : n3;
    return o3.innerHTML = i2, o3;
  })(t2, n2.options.title)), n2.options.cancelIcon && n2.options.cancelIcon.enabled && o2.append((function(t3, e2) {
    return ne("button", { "aria-label": t3.label ? t3.label : "Close Tour", class: "shepherd-cancel-icon", onclick: (t4) => {
      t4.preventDefault(), e2.cancel();
    }, type: "button" }, ne("span", { "aria-hidden": "true" }, "Ã—"));
  })(n2.options.cancelIcon, n2)), o2;
}
function ae(n2, i2, s2) {
  const r2 = ne("div", { class: "shepherd-content" });
  return (!o(s2.options.title) || s2.options.cancelIcon && s2.options.cancelIcon.enabled) && r2.append(ce(i2, s2)), o(s2.options.text) || r2.append((function(n3, o2) {
    const i3 = ne("div", { class: "shepherd-text", id: n3 });
    let s3 = o2.options.text;
    return e(s3) && (s3 = s3.call(o2)), t(s3) ? i3.appendChild(s3) : i3.innerHTML = s3, i3;
  })(n2, s2)), Array.isArray(s2.options.buttons) && s2.options.buttons.length && r2.append((function(t2) {
    const e2 = ne("footer", { class: "shepherd-footer" });
    if (t2.options.buttons) for (const n3 of t2.options.buttons) e2.append(le(n3, t2));
    return e2;
  })(s2)), r2;
}
var ue = class extends i {
  constructor(t2, e2 = {}) {
    return super(), this._resolvedAttachTo = void 0, this._resolvedExtraHighlightElements = void 0, this._originalTabIndexes = void 0, this.classPrefix = void 0, this.el = void 0, this.shepherdElementComponent = void 0, this.target = void 0, this.tour = void 0, this.tour = t2, this.classPrefix = this.tour.options ? w(this.tour.options.classPrefix) : "", this.styles = t2.styles, this._resolvedAttachTo = null, this._originalTabIndexes = /* @__PURE__ */ new Map(), x(this), this._setOptions(e2), this;
  }
  cancel() {
    this.tour.cancel(), this.trigger("cancel");
  }
  complete() {
    this.tour.complete(), this.trigger("complete");
  }
  destroy() {
    this._teardownElements(), this.trigger("destroy");
  }
  _teardownElements() {
    var e2;
    (e2 = this).cleanup && e2.cleanup(), e2.cleanup = null, this.shepherdElementComponent && (this.shepherdElementComponent.cleanup(), this.shepherdElementComponent = void 0), t(this.el) && (this.el.remove(), this.el = null), this._updateStepTargetOnHide(), this._originalTabIndexes.clear();
  }
  getTour() {
    return this.tour;
  }
  hide() {
    var t2;
    null == (t2 = this.tour.modal) || t2.hide(), this.trigger("before-hide"), this.el && (this.el.hidden = true), this._updateStepTargetOnHide(), this.trigger("hide");
  }
  _resolveExtraHiglightElements() {
    var t2;
    return this._resolvedExtraHighlightElements = (t2 = this).options.extraHighlights ? t2.options.extraHighlights.flatMap((t3) => Array.from(document.querySelectorAll(t3))) : [], this._resolvedExtraHighlightElements;
  }
  _resolveAttachToOptions() {
    return this._resolvedAttachTo = (function(t2) {
      const o2 = t2.options.attachTo || {}, i2 = Object.assign({}, o2);
      if (e(i2.element) && (i2.element = i2.element.call(t2)), n(i2.element)) {
        try {
          i2.element = document.querySelector(i2.element);
        } catch (t3) {
        }
        i2.element;
      }
      return i2;
    })(this), this._resolvedAttachTo;
  }
  _getResolvedAttachToOptions() {
    return null === this._resolvedAttachTo ? this._resolveAttachToOptions() : this._resolvedAttachTo;
  }
  isOpen() {
    return Boolean(this.el && !this.el.hidden);
  }
  show() {
    return e(this.options.beforeShowPromise) ? Promise.resolve(this.options.beforeShowPromise()).then(() => this._show()) : Promise.resolve(this._show());
  }
  updateStepOptions(t2) {
    Object.assign(this.options, t2), this.shepherdElementComponent && this.el && (this._teardownElements(), this._setupElements());
  }
  getElement() {
    return this.el;
  }
  getTarget() {
    return this.target;
  }
  _storeOriginalTabIndex(t2) {
    const e2 = t2.getAttribute("tabindex");
    null !== e2 && this._originalTabIndexes.set(t2, e2);
  }
  _restoreOriginalTabIndexes() {
    const t2 = this.target;
    t2 && (this._originalTabIndexes.has(t2) ? t2.setAttribute("tabindex", this._originalTabIndexes.get(t2)) : t2.removeAttribute("tabindex"));
  }
  _createTooltipContent() {
    const t2 = `${this.id}-description`, e2 = `${this.id}-label`;
    this.shepherdElementComponent = (function(t3) {
      var e3, i2, s2, r2;
      const { classPrefix: l2, descriptionId: c2, labelId: a2, step: u2 } = t3;
      let h2, d2, f2, p2, g2, m2, v2;
      const y2 = null != (e3 = null == (i2 = u2.options) || null == (i2 = i2.cancelIcon) ? void 0 : i2.enabled) && e3, x2 = null != (s2 = null == (r2 = u2.options) ? void 0 : r2.title) && s2, b2 = (t4) => {
        const { tour: e4 } = u2;
        switch (t4.keyCode) {
          case 9:
            if ((!d2 || 0 === d2.length) && m2 && 0 === m2.length) {
              t4.preventDefault();
              break;
            }
            var n2, o2, i3;
            if (t4.shiftKey) {
              if (document.activeElement === g2 || null != (n2 = document.activeElement) && n2.classList.contains("shepherd-element")) t4.preventDefault(), null == (o2 = null != p2 ? p2 : v2) || o2.focus();
              else if (document.activeElement === f2) {
                var s3;
                t4.preventDefault(), null == (s3 = v2) || s3.focus();
              }
            } else if (document.activeElement === v2) t4.preventDefault(), null == (i3 = null != f2 ? f2 : g2) || i3.focus();
            else if (document.activeElement === p2) {
              var r3;
              t4.preventDefault(), null == (r3 = g2) || r3.focus();
            }
            break;
          case 27:
            e4.options.exitOnEsc && (t4.preventDefault(), t4.stopPropagation(), u2.cancel());
            break;
          case 37:
            e4.options.keyboardNavigation && (t4.preventDefault(), t4.stopPropagation(), e4.back());
            break;
          case 39:
            e4.options.keyboardNavigation && (t4.preventDefault(), t4.stopPropagation(), e4.next());
        }
      }, w2 = ne("dialog", { "aria-describedby": o(u2.options.text) ? null : c2, "aria-labelledby": u2.options.title ? a2 : null, class: ["shepherd-element", y2 ? "shepherd-has-cancel-icon" : "", x2 ? "shepherd-has-title" : ""].filter(Boolean).join(" "), [`data-${l2}shepherd-step-id`]: u2.id, onkeydown: b2, open: "true" });
      if (u2.options.arrow && u2.options.attachTo && u2.options.attachTo.element && u2.options.attachTo.on && w2.append(ne("div", { class: "shepherd-arrow", "data-popper-arrow": "" })), w2.append(ae(c2, a2, u2)), n(u2.options.classes)) {
        const t4 = u2.options.classes.split(" ").filter((t5) => !!t5.length);
        t4.length && w2.classList.add(...t4);
      }
      const E2 = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex="0"]';
      m2 = [...w2.querySelectorAll(E2)], g2 = m2[0], v2 = m2[m2.length - 1];
      const O2 = u2._getResolvedAttachToOptions();
      return null != O2 && O2.element && (h2 = O2.element, u2._storeOriginalTabIndex(h2), h2.tabIndex = 0, d2 = [h2, ...h2.querySelectorAll(E2)], f2 = d2[0], p2 = d2[d2.length - 1], h2.addEventListener("keydown", b2)), { element: w2, cleanup: () => {
        var t4;
        null == (t4 = h2) || t4.removeEventListener("keydown", b2);
      } };
    })({ classPrefix: this.classPrefix, descriptionId: t2, labelId: e2, step: this });
    return (this.tour.options.stepsContainer || document.body).append(this.shepherdElementComponent.element), this.shepherdElementComponent.element;
  }
  _scrollTo(t2) {
    const { element: n2 } = this._getResolvedAttachToOptions();
    e(this.options.scrollToHandler) ? this.options.scrollToHandler(n2) : n2 instanceof Element && "function" == typeof n2.scrollIntoView && n2.scrollIntoView(t2);
  }
  _getClassOptions(t2) {
    const e2 = this.tour && this.tour.options && this.tour.options.defaultStepOptions, n2 = t2.classes ? t2.classes : "", o2 = e2 && e2.classes ? e2.classes : "", i2 = [...n2.split(" "), ...o2.split(" ")], s2 = new Set(i2);
    return Array.from(s2).join(" ").trim();
  }
  _setOptions(t2 = {}) {
    let e2 = this.tour && this.tour.options && this.tour.options.defaultStepOptions;
    e2 = m({}, e2 || {}), this.options = Object.assign({ arrow: true }, e2, t2, (function(t3, e3) {
      return { floatingUIOptions: m(t3.floatingUIOptions || {}, e3.floatingUIOptions || {}) };
    })(e2, t2));
    const { when: n2 } = this.options;
    this.options.classes = this._getClassOptions(t2), this.destroy(), this.id = this.options.id || `step-${O()}`, n2 && Object.keys(n2).forEach((t3) => {
      this.on(t3, n2[t3], this);
    });
  }
  _setupElements() {
    o(this.el) || this.destroy(), this.el = this._createTooltipContent(), this.options.advanceOn && b(this), ee(this);
  }
  _show() {
    var t2;
    this.trigger("before-show"), this._resolveAttachToOptions(), this._resolveExtraHiglightElements(), this._setupElements(), this.tour.modal || this.tour.setupModal(), null == (t2 = this.tour.modal) || t2.setupForStep(this), this._styleTargetElementForStep(this), this.el && (this.el.hidden = false), this.options.scrollTo && setTimeout(() => {
      this._scrollTo(this.options.scrollTo);
    }), this.el && (this.el.hidden = false);
    const e2 = this.shepherdElementComponent.element, n2 = this.target || document.body, o2 = this._resolvedExtraHighlightElements;
    n2.classList.add(`${this.classPrefix}shepherd-enabled`), n2.classList.add(`${this.classPrefix}shepherd-target`), e2.classList.add("shepherd-enabled"), null == o2 || o2.forEach((t3) => {
      t3.classList.add(`${this.classPrefix}shepherd-enabled`), t3.classList.add(`${this.classPrefix}shepherd-target`);
    }), this.trigger("show");
  }
  _styleTargetElementForStep(t2) {
    const e2 = t2.target, n2 = t2._resolvedExtraHighlightElements;
    if (!e2) return;
    const o2 = t2.options.highlightClass;
    o2 && (e2.classList.add(o2), null == n2 || n2.forEach((t3) => t3.classList.add(o2))), e2.classList.remove("shepherd-target-click-disabled"), null == n2 || n2.forEach((t3) => t3.classList.remove("shepherd-target-click-disabled")), false === t2.options.canClickTarget && (e2.classList.add("shepherd-target-click-disabled"), null == n2 || n2.forEach((t3) => t3.classList.add("shepherd-target-click-disabled")));
  }
  _updateStepTargetOnHide() {
    const t2 = this.target || document.body, e2 = this._resolvedExtraHighlightElements, n2 = this.options.highlightClass;
    n2 && (t2.classList.remove(n2), null == e2 || e2.forEach((t3) => t3.classList.remove(n2))), t2.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`), null == e2 || e2.forEach((t3) => {
      t3.classList.remove("shepherd-target-click-disabled", `${this.classPrefix}shepherd-enabled`, `${this.classPrefix}shepherd-target`);
    }), this._restoreOriginalTabIndexes();
  }
};
function he(t2) {
  let e2, n2 = [{ width: 0, height: 0, x: 0, y: 0, r: 0 }];
  const o2 = oe("path"), i2 = oe("svg", { class: "shepherd-modal-overlay-container" }, o2);
  function s2() {
    o2.setAttribute("d", (function(t3) {
      let e3 = "";
      const { innerWidth: n3, innerHeight: o3 } = window;
      return t3.forEach((t4) => {
        const { width: n4, height: o4, x: i3 = 0, y: s3 = 0, r: r3 = 0 } = t4, { topLeft: l3 = 0, topRight: c3 = 0, bottomRight: a3 = 0, bottomLeft: u3 = 0 } = "number" == typeof r3 ? { topLeft: r3, topRight: r3, bottomRight: r3, bottomLeft: r3 } : r3;
        e3 += `M${i3 + l3},${s3}      a${l3},${l3},0,0,0-${l3},${l3}      V${o4 + s3 - u3}      a${u3},${u3},0,0,0,${u3},${u3}      H${n4 + i3 - a3}      a${a3},${a3},0,0,0,${a3}-${a3}      V${s3 + c3}      a${c3},${c3},0,0,0-${c3}-${c3}      Z`;
      }), `M${n3},${o3}          H0          V0          H${n3}          V${o3}          Z          ${e3}`.replace(/\s/g, "");
    })(n2));
  }
  function r2() {
    n2 = [{ width: 0, height: 0, x: 0, y: 0, r: 0 }], s2();
  }
  function l2() {
    i2.classList.remove("shepherd-modal-is-visible"), d2();
  }
  function c2() {
    i2.classList.add("shepherd-modal-is-visible");
  }
  function a2(t3 = 0, e3 = 0, o3 = 0, i3 = 0, l3, c3, a3) {
    if (c3) {
      {
        const s3 = [c3, ...a3 || []], r3 = [];
        for (const n3 of s3) {
          if (!n3) continue;
          if (s3.indexOf(n3) !== s3.lastIndexOf(n3)) continue;
          const { y: c4, height: a4 } = p2(n3, l3), { x: u3, width: h3, left: d3 } = n3.getBoundingClientRect();
          s3.some((t4) => {
            if (t4 === n3) return false;
            const e4 = t4.getBoundingClientRect(), { y: o4, height: i4 } = p2(t4, l3);
            return u3 >= e4.left && u3 + h3 <= e4.left + e4.width && c4 >= o4 && c4 + a4 <= o4 + i4;
          }) || r3.push({ width: h3 + 2 * t3, height: a4 + 2 * t3, x: (u3 || d3) + o3 - t3, y: c4 + i3 - t3, r: e3 });
        }
        n2 = r3;
      }
      s2();
    } else r2();
  }
  function u2(t3) {
    t3.stopPropagation();
  }
  i2.addEventListener("touchmove", u2), s2(), t2.append(i2);
  const h2 = (t3) => {
    t3.preventDefault();
  };
  function d2() {
    e2 && (cancelAnimationFrame(e2), e2 = void 0), window.removeEventListener("touchmove", h2, { passive: false });
  }
  function f2(t3) {
    if (!t3) return null;
    const e3 = t3 instanceof HTMLElement && window.getComputedStyle(t3).overflowY;
    return "hidden" !== e3 && "visible" !== e3 && t3.scrollHeight >= t3.clientHeight ? t3 : f2(t3.parentElement);
  }
  function p2(t3, e3) {
    const n3 = t3.getBoundingClientRect();
    let o3 = n3.y || n3.top, i3 = n3.bottom || o3 + n3.height;
    if (e3) {
      const t4 = e3.getBoundingClientRect(), n4 = t4.y || t4.top, s3 = t4.bottom || n4 + t4.height;
      o3 = Math.max(o3, n4), i3 = Math.min(i3, s3);
    }
    return { y: o3, height: Math.max(i3 - o3, 0) };
  }
  return { closeModalOpening: r2, destroy: function() {
    d2(), i2.removeEventListener("touchmove", u2), i2.remove();
  }, hide: l2, positionModal: a2, setupForStep: function(t3) {
    d2(), t3.tour.options.useModalOverlay ? (!(function(t4) {
      const { modalOverlayOpeningPadding: n3, modalOverlayOpeningRadius: o3, modalOverlayOpeningXOffset: i3 = 0, modalOverlayOpeningYOffset: s3 = 0 } = t4.options, r3 = (function(t5) {
        const e3 = { top: 0, left: 0 };
        if (!t5) return e3;
        let n4 = t5.ownerDocument.defaultView;
        try {
          for (; n4 && n4 !== window.top; ) {
            var o4;
            const t6 = null == (o4 = n4) ? void 0 : o4.frameElement;
            if (t6) {
              const n5 = t6.getBoundingClientRect();
              e3.top += n5.top + t6.scrollTop, e3.left += n5.left + t6.scrollLeft;
            }
            n4 = n4.parent;
          }
        } catch (t6) {
        }
        return e3;
      })(t4.target), l3 = f2(t4.target), c3 = () => {
        e2 = void 0, a2(n3, o3, i3 + r3.left, s3 + r3.top, l3, t4.target, t4._resolvedExtraHighlightElements), e2 = requestAnimationFrame(c3);
      };
      c3(), window.addEventListener("touchmove", h2, { passive: false });
    })(t3), c2()) : l2();
  }, show: c2, getElement: function() {
    return i2;
  } };
}
var de = class extends i {
  constructor() {
    super(), this.activeTour = void 0, x(this);
  }
};
var fe = new de();
var pe = "undefined" == typeof window;
fe.Step = pe ? class {
  constructor(t2) {
  }
} : ue, fe.Tour = pe ? class {
  constructor(t2, e2) {
  }
} : class extends i {
  constructor(t2 = {}) {
    super(), this.trackedEvents = ["active", "cancel", "complete", "show"], this.classPrefix = void 0, this.currentStep = void 0, this.focusedElBeforeOpen = void 0, this.id = void 0, this.modal = void 0, this.options = void 0, this.steps = void 0, x(this);
    this.options = Object.assign({}, { exitOnEsc: true, keyboardNavigation: true }, t2), this.classPrefix = w(this.options.classPrefix), this.steps = [], this.addSteps(this.options.steps);
    return ["active", "cancel", "complete", "inactive", "show", "start"].map((t3) => {
      ((t4) => {
        this.on(t4, (e2) => {
          (e2 = e2 || {}).tour = this, fe.trigger(t4, e2);
        });
      })(t3);
    }), this._setTourID(t2.id), this;
  }
  addStep(t2, e2) {
    let n2 = t2;
    return n2 instanceof ue ? n2.tour = this : n2 = new ue(this, n2), o(e2) ? this.steps.push(n2) : this.steps.splice(e2, 0, n2), n2;
  }
  addSteps(t2) {
    return Array.isArray(t2) && t2.forEach((t3) => {
      this.addStep(t3);
    }), this;
  }
  back() {
    const t2 = this.steps.indexOf(this.currentStep);
    this.show(t2 - 1, false);
  }
  async cancel() {
    if (this.options.confirmCancel) {
      const t2 = this.options.confirmCancelMessage || "Are you sure you want to stop the tour?";
      let n2;
      n2 = e(this.options.confirmCancel) ? await this.options.confirmCancel() : window.confirm(t2), n2 && this._done("cancel");
    } else this._done("cancel");
  }
  complete() {
    this._done("complete");
  }
  getById(t2) {
    return this.steps.find((e2) => e2.id === t2);
  }
  getCurrentStep() {
    return this.currentStep;
  }
  hide() {
    const t2 = this.getCurrentStep();
    if (t2) return t2.hide();
  }
  isActive() {
    return fe.activeTour === this;
  }
  next() {
    const t2 = this.steps.indexOf(this.currentStep);
    t2 === this.steps.length - 1 ? this.complete() : this.show(t2 + 1, true);
  }
  removeStep(t2) {
    const e2 = this.getCurrentStep();
    this.steps.some((e3, n2) => {
      if (e3.id === t2) return e3.isOpen() && e3.hide(), e3.destroy(), this.steps.splice(n2, 1), true;
    }), e2 && e2.id === t2 && (this.currentStep = void 0, this.steps.length ? this.show(0) : this.cancel());
  }
  show(t2 = 0, o2 = true) {
    const i2 = n(t2) ? this.getById(t2) : this.steps[t2];
    if (i2) {
      this._updateStateBeforeShow();
      e(i2.options.showOn) && !i2.options.showOn() ? this._skipStep(i2, o2) : (this.currentStep = i2, this.trigger("show", { step: i2, previous: this.currentStep }), i2.show());
    }
  }
  async start() {
    this.trigger("start"), this.focusedElBeforeOpen = document.activeElement, this.currentStep = null, this.setupModal(), this._setupActiveTour(), this.next();
  }
  _done(e2) {
    const n2 = this.steps.indexOf(this.currentStep);
    Array.isArray(this.steps) && this.steps.forEach((t2) => t2.destroy()), (function(e3) {
      if (e3) {
        const { steps: n3 } = e3;
        n3.forEach((e4) => {
          e4.options && false === e4.options.canClickTarget && e4.options.attachTo && (t(e4.target) && e4.target.classList.remove("shepherd-target-click-disabled"), e4._resolvedExtraHighlightElements && e4._resolvedExtraHighlightElements.forEach((e5) => {
            t(e5) && e5.classList.remove("shepherd-target-click-disabled");
          }));
        });
      }
    })(this), this.trigger(e2, { index: n2 }), fe.activeTour = null, this.trigger("inactive", { tour: this }), this.modal && this.modal.hide(), "cancel" !== e2 && "complete" !== e2 || this.modal && (this.modal.destroy(), this.modal = null), t(this.focusedElBeforeOpen) && this.focusedElBeforeOpen.focus();
  }
  _setupActiveTour() {
    this.trigger("active", { tour: this }), fe.activeTour = this;
  }
  setupModal() {
    const t2 = this.options.modalContainer || document.body;
    this.modal = he(t2);
  }
  _skipStep(t2, e2) {
    const n2 = this.steps.indexOf(t2);
    if (n2 === this.steps.length - 1) this.complete();
    else {
      const t3 = e2 ? n2 + 1 : n2 - 1;
      this.show(t3, e2);
    }
  }
  _updateStateBeforeShow() {
    this.currentStep && this.currentStep.hide(), this.isActive() || this._setupActiveTour();
  }
  _setTourID(t2) {
    const e2 = this.options.tourName || "tour", n2 = t2 || O();
    this.id = `${e2}--${n2}`;
  }
};
export {
  de as ShepherdBase,
  fe as default
};
//# sourceMappingURL=shepherd__js.js.map
